# 内存管理系统配置总结

**日期**: 2025-12-28
**状态**: Buddy System 成功运行

## 1. 虚拟地址空间布局

```
用户空间: 0x00000000 - 0xBFFFFFFF (0-3GB)
内核空间: 0xC0000000 - 0xFFFFFFFF (3-4GB)
```

## 2. 物理内存映射机制

### 2.1 Boot.s 初始映射
boot.s 中建立的页表映射：

```assembly
pd[0]   = pt   → 虚拟 0x00000000-0x003FFFFF → 物理 0x00000000-0x003FFFFF (4MB)
pd[0x300] = pt   → 虚拟 0xC0000000-0xC03FFFFF → 物理 0x00000000-0x003FFFFF (4MB)
pd[0x301] = pt   → 虚拟 0xC0400000-0xC07FFFFF → 物理 0x00000000-0x003FFFFF (重复映射)
pd[0xC00] = pt   → 虚拟 0xF0000000-0xF03FFFFF → 物理 0x00000000-0x003FFFFF (兼容性)
```

**重要**: 只有前 4MB 物理内存在启动时被映射到内核虚拟地址空间。

### 2.2 按需映射机制

系统使用 `map_4k_page()` 函数实现按需映射：

- 当访问未映射的虚拟地址时，`map_4k_page()` 会自动创建新的页表
- 新页表通过 `pmm_alloc_page()` 分配
- 这样可以避免预映射大量内存导致的性能问题

**关键代码** ([page.c:190](hillson_test_os/page.c#L190)):
```c
void map_4k_page(uint32_t phys_addr, uint32_t virt_addr, uint32_t flags) {
    if (!(high_page_directory[pd_index] & 0x1)) {
        // 自动分配新页表
        uint32_t* new_pt = alloc_page_table(virt_addr, phys_addr, flags);
    }
}
```

## 3. Buddy System 配置

### 3.1 数据结构位置

```
物理地址: 0x1000000 (16MB)
预留空间: 20 MB
虚拟地址: 0xC1000000 (通过按需映射访问)
```

**关键**: 虽然 16MB 在 boot.s 中未被映射，但当首次访问 `0xC1000000` 时，系统会自动建立页表。

### 3.2 管理的内存范围

```
起始地址: 0x2400000 (36MB)
结束地址: 根据实际检测的物理内存大小
管理页数: 动态计算
```

### 3.3 内存布局图

```
物理内存布局:
+------------------+ 0x00000000 (0MB)
|   内核代码/数据   |
|   (约 3.7MB)     |
+------------------+ 0x003A6000 (~3.7MB)
|   内核 BSS       |
+------------------+ 0x00400000 (4MB) ← boot.s 映射边界
|   未映射空间     |
|   (4MB - 16MB)   |
+------------------+ 0x01000000 (16MB)
|   Buddy 数据结构 |
|   (20MB 预留)    |
+------------------+ 0x02400000 (36MB) ← PMM 管理起始
|   Buddy 管理的   |
|   物理内存池     |
+------------------+ 0xXXXXXXXX (内存顶部)
```

## 4. 关键宏和常量

### 4.1 地址转换宏

```c
#define KERNEL_VIRT_BASE   0xC0000000
#define V2P(a) (((uint32_t)(a)) - KERNBASE)
#define P2V(a) ((void*)(((char*)(a)) + KERNBASE))
#define phys_to_virt(pa) ((void*)((uint32_t)(pa) + KERNEL_VA_OFFSET))
```

### 4.2 重要常量

```c
#define PAGE_SIZE         4096
#define IDENTITY_MAP_SIZE 0x0800000  // 8MB (注释值，实际只有 4MB)
```

## 5. 初始化顺序

```
1. boot.s - 建立前 4MB 映射
2. kernel_main()
   ├─ init_highmem_mapping() - 记录映射信息
   ├─ mm_init()
   │   └─ pmm_init()
   │       ├─ 设置 buddy 数据在 16MB
   │       └─ buddy_init() - 首次访问 0xC1000000 时触发按需映射
   └─ 其他初始化...
```

## 6. 关键文件

| 文件 | 作用 |
|------|------|
| [boot.s](hillson_test_os/boot.s) | 启动时页表初始化（4MB映射）|
| [page.c](hillson_test_os/page.c) | 按需映射实现（map_4k_page）|
| [kmalloc_early.c](hillson_test_os/kmalloc_early.c) | PMM 和 Buddy System 初始化 |
| [buddy.c](hillson_test_os/mm/buddy.c) | Buddy System 实现 |
| [memlayout.h](hillson_test_os/include/memlayout.h) | 内存布局定义 |
| [highmem_mapping.h](hillson_test_os/include/highmem_mapping.h) | 高端内存映射接口 |

## 7. 注意事项

### ⚠️ 关键约束

1. **Buddy System 数据必须在可通过按需映射访问的地址**
   - 当前配置: 16MB (0x1000000)
   - 首次访问时会自动建立页表

2. **管理的内存从 36MB 开始**
   - 0-4MB: 内核和初始映射
   - 4-16MB: 保留
   - 16-36MB: Buddy 数据结构
   - 36MB+: Buddy 管理的内存池

3. **按需映射依赖 pmm_alloc_page()**
   - 必须在 pmm_init() 之后才能使用按需映射
   - 初始化顺序很重要

### ✅ 成功标志

系统成功运行的特征：
- [x] 内核启动不重启
- [x] Buddy System 初始化成功
- [x] 内存分配和释放正常工作
- [x] 测试程序全部通过

## 8. 测试结果

使用 512MB 内存测试：
- 检测到 510MB 可用物理内存
- Buddy System 管理 475 MB (121,728 页)
- 所有 kmalloc/kfree 测试通过
- 内存隔离测试通过

使用 4GB 内存测试：
- 检测到 3070MB 可用物理内存
- Buddy System 管理 3035 MB (777,088 页)
- 启动时间约 20-30 秒（需要映射更多页表）

## 9. 实体机兼容性

- **问题**: 预映射 4GB 需要约 1GB 页表内存，导致实体机闪退
- **解决**: 使用按需映射，只在访问时创建页表
- **状态**: 待在实际硬件上测试

## 10. 下一步优化

1. 在实际硬件上测试稳定性
2. 优化页表分配策略
3. 添加内存热插拔支持
4. 实现内存压缩功能
