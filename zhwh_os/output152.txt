c[?7l[2J[0mSeaBIOS (version 1.16.3-debian-1.16.3-2)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1EFCAF60+1EF0AF60 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from Hard Disk...
GRUB [01;01H[2J[02;30HGN[02;31H[02;32HU GRUB  version 2.12[04;02Hâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[04;37H[04;38Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[04;56H[04;57Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€[04;65H[04;66Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”[05;02Hâ”‚[05;79Hâ”‚[05;79H[06;02Hâ”‚[06;79Hâ”‚[07;02Hâ”‚[07;79Hâ”‚[08;02Hâ”‚[08;79Hâ”‚[09;02Hâ”‚[09;79Hâ”‚[10;02Hâ”‚[10;79Hâ”‚[11;02Hâ”‚[11;79Hâ”‚[11;79H[12;02Hâ”‚[12;79Hâ”‚[13;02Hâ”‚[13;02H[13;79Hâ”‚[14;02Hâ”‚[14;79Hâ”‚[15;02Hâ”‚[15;79Hâ”‚[16;02Hâ”‚[16;79Hâ”‚[17;02Hâ”‚[17;79Hâ”‚[17;79H[18;02Hâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[18;23H[18;24Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[18;41H[18;42Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[18;66H[18;67Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜[20;02H     Us[20;08H[20;09He[20;09H[20;10H the â†‘ and â†“ [20;22H[20;23Hkeys to select which entry is highlighted.          
      Press enter to boot the selected OS, `e' to edit the com[21;62H[21;63Hmands       
      before booting or `c' for a command-line.                           [05;80H [05;03H My OS - Direct Write Test                                                  [06;03H [06;03H[06;04HMy OS - Simple printf Test                                                 [07;03H[0;30;47m*My O[07;07H[07;08HS[07;08H[07;09H - 5 Process T[07;22H[07;23Hest          [07;35H[07;36H          [07;45H[07;46H                [07;61H[07;62H         [07;70H[07;71H        [08;03H[0m My OS - shell_demo Test                                     [08;63H[08;64H               [09;03H M[09;04H[09;05Hy OS - Simple Syscall Test       [09;37H[09;38H                                    [09;73H[09;74H     [10;03H My OS [10;09H[10;10H- File System Test                         [10;52H[10;53H                [10;68H[10;69H          [11;03H      [11;08H[11;09H                     [11;29H[11;30H                          [11;55H[11;56H                       [12;03H    [12;06H[12;07H                   [12;25H[12;26H                                              [12;71H[12;72H       [13;03H                             [13;31H[13;32H                     [13;52H[13;53H                          [14;03H        [14;10H[14;11H                                         [14;51H[14;52H                           [15;03H     [15;07H[15;08H                                  [15;41H[15;42H                               [15;72H[15;73H      [16;03H                           [16;29H[16;30H                                           [16;72H[16;73H      [17;03H         [17;11H[17;12H                                  [17;45H[17;46H                   [17;64H[17;65H              [17;80H 





   The highlighted entry will be executed automatically in 5s.                 [07;78H















   The highlighted entry will be executed automatically in 4s.                 [07;78H















 [23;02H  The highlighted entry will be executed automatically in 3s.                 [07;78H















 [23;02H  The highlighted entry will be exec[23;37H[23;38Huted automat[23;49H[23;50Hically in 2s.     [23;67H[23;68H            [07;78H















   The highlighted entry[23;24H[23;25H will be executed automatically in 1s.                 [07;78H















   The highlighted entry will be executed automatically in 0s.                 [01;01H[2J[2J[kernel_main] Saved kernel CR3 phys=0x101000
=== Serial initialized ===
Kernel Booted with Multiboot 2!
Magic: 0x36D76289
Info addr: 0x106010
cpuid is 0 
lapicid is 0 
 ---IOAPIC ---
ioapicid is 0 
ioapic addr is is 0xFEC00000 
Highmem mapping initialized
Identity mapped: 0xC0000000-0xC03FFFFF
Mapping buddy system metadata area (phys 16MB-48MB, 32MB total)...
Allocating new page table for directory entry 772
alloc_page_table: virt=0xC1000000, phys=0x1000000, pd_idx=772
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x200000, virt=0xC0200000
  Allocated PT at phys=0x200000
  Writing PDE: pd[772] = 0x200003
  pd[772] now = 0x200003
  pt_virt = 0xC0200000 (from pd[772]=0x200003)
  Clearing page table...
  Filling PTEs: phys=0x1000000 -> virt=0xC1000000
  Flushing TLB for virt=0xC1000000
  Done!
Allocated new page table for directory entry 0xC1000000
Allocated new page table for directory entry 0xC1000000
phys_addr is 0x1000000
virt_addr is 0xC1000000
pte is 0x0
  Mapped 0xC1000000 (phys 0x1000000)
  Mapped 0xC1100000 (phys 0x1100000)
  Mapped 0xC1200000 (phys 0x1200000)
  Mapped 0xC1300000 (phys 0x1300000)
Allocating new page table for directory entry 773
alloc_page_table: virt=0xC1400000, phys=0x1400000, pd_idx=773
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x201000, virt=0xC0201000
  Allocated PT at phys=0x201000
  Writing PDE: pd[773] = 0x201003
  pd[773] now = 0x201003
  pt_virt = 0xC0201000 (from pd[773]=0x201003)
  Clearing page table...
  Filling PTEs: phys=0x1400000 -> virt=0xC1400000
  Flushing TLB for virt=0xC1400000
  Done!
Allocated new page table for directory entry 0xC1400000
Allocated new page table for directory entry 0xC1400000
phys_addr is 0x1400000
virt_addr is 0xC1400000
pte is 0x0
  Mapped 0xC1400000 (phys 0x1400000)
  Mapped 0xC1500000 (phys 0x1500000)
  Mapped 0xC1600000 (phys 0x1600000)
  Mapped 0xC1700000 (phys 0x1700000)
Allocating new page table for directory entry 774
alloc_page_table: virt=0xC1800000, phys=0x1800000, pd_idx=774
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x202000, virt=0xC0202000
  Allocated PT at phys=0x202000
  Writing PDE: pd[774] = 0x202003
  pd[774] now = 0x202003
  pt_virt = 0xC0202000 (from pd[774]=0x202003)
  Clearing page table...
  Filling PTEs: phys=0x1800000 -> virt=0xC1800000
  Flushing TLB for virt=0xC1800000
  Done!
Allocated new page table for directory entry 0xC1800000
Allocated new page table for directory entry 0xC1800000
phys_addr is 0x1800000
virt_addr is 0xC1800000
pte is 0x0
  Mapped 0xC1800000 (phys 0x1800000)
  Mapped 0xC1900000 (phys 0x1900000)
  Mapped 0xC1A00000 (phys 0x1A00000)
  Mapped 0xC1B00000 (phys 0x1B00000)
Allocating new page table for directory entry 775
alloc_page_table: virt=0xC1C00000, phys=0x1C00000, pd_idx=775
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x203000, virt=0xC0203000
  Allocated PT at phys=0x203000
  Writing PDE: pd[775] = 0x203003
  pd[775] now = 0x203003
  pt_virt = 0xC0203000 (from pd[775]=0x203003)
  Clearing page table...
  Filling PTEs: phys=0x1C00000 -> virt=0xC1C00000
  Flushing TLB for virt=0xC1C00000
  Done!
Allocated new page table for directory entry 0xC1C00000
Allocated new page table for directory entry 0xC1C00000
phys_addr is 0x1C00000
virt_addr is 0xC1C00000
pte is 0x0
  Mapped 0xC1C00000 (phys 0x1C00000)
  Mapped 0xC1D00000 (phys 0x1D00000)
  Mapped 0xC1E00000 (phys 0x1E00000)
  Mapped 0xC1F00000 (phys 0x1F00000)
Allocating new page table for directory entry 776
alloc_page_table: virt=0xC2000000, phys=0x2000000, pd_idx=776
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x204000, virt=0xC0204000
  Allocated PT at phys=0x204000
  Writing PDE: pd[776] = 0x204003
  pd[776] now = 0x204003
  pt_virt = 0xC0204000 (from pd[776]=0x204003)
  Clearing page table...
  Filling PTEs: phys=0x2000000 -> virt=0xC2000000
  Flushing TLB for virt=0xC2000000
  Done!
Allocated new page table for directory entry 0xC2000000
Allocated new page table for directory entry 0xC2000000
phys_addr is 0x2000000
virt_addr is 0xC2000000
pte is 0x0
  Mapped 0xC2000000 (phys 0x2000000)
  Mapped 0xC2100000 (phys 0x2100000)
  Mapped 0xC2200000 (phys 0x2200000)
  Mapped 0xC2300000 (phys 0x2300000)
Allocating new page table for directory entry 777
alloc_page_table: virt=0xC2400000, phys=0x2400000, pd_idx=777
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x205000, virt=0xC0205000
  Allocated PT at phys=0x205000
  Writing PDE: pd[777] = 0x205003
  pd[777] now = 0x205003
  pt_virt = 0xC0205000 (from pd[777]=0x205003)
  Clearing page table...
  Filling PTEs: phys=0x2400000 -> virt=0xC2400000
  Flushing TLB for virt=0xC2400000
  Done!
Allocated new page table for directory entry 0xC2400000
Allocated new page table for directory entry 0xC2400000
phys_addr is 0x2400000
virt_addr is 0xC2400000
pte is 0x0
  Mapped 0xC2400000 (phys 0x2400000)
  Mapped 0xC2500000 (phys 0x2500000)
  Mapped 0xC2600000 (phys 0x2600000)
  Mapped 0xC2700000 (phys 0x2700000)
Allocating new page table for directory entry 778
alloc_page_table: virt=0xC2800000, phys=0x2800000, pd_idx=778
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x206000, virt=0xC0206000
  Allocated PT at phys=0x206000
  Writing PDE: pd[778] = 0x206003
  pd[778] now = 0x206003
  pt_virt = 0xC0206000 (from pd[778]=0x206003)
  Clearing page table...
  Filling PTEs: phys=0x2800000 -> virt=0xC2800000
  Flushing TLB for virt=0xC2800000
  Done!
Allocated new page table for directory entry 0xC2800000
Allocated new page table for directory entry 0xC2800000
phys_addr is 0x2800000
virt_addr is 0xC2800000
pte is 0x0
  Mapped 0xC2800000 (phys 0x2800000)
  Mapped 0xC2900000 (phys 0x2900000)
  Mapped 0xC2A00000 (phys 0x2A00000)
  Mapped 0xC2B00000 (phys 0x2B00000)
Allocating new page table for directory entry 779
alloc_page_table: virt=0xC2C00000, phys=0x2C00000, pd_idx=779
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x207000, virt=0xC0207000
  Allocated PT at phys=0x207000
  Writing PDE: pd[779] = 0x207003
  pd[779] now = 0x207003
  pt_virt = 0xC0207000 (from pd[779]=0x207003)
  Clearing page table...
  Filling PTEs: phys=0x2C00000 -> virt=0xC2C00000
  Flushing TLB for virt=0xC2C00000
  Done!
Allocated new page table for directory entry 0xC2C00000
Allocated new page table for directory entry 0xC2C00000
phys_addr is 0x2C00000
virt_addr is 0xC2C00000
pte is 0x0
  Mapped 0xC2C00000 (phys 0x2C00000)
  Mapped 0xC2D00000 (phys 0x2D00000)
  Mapped 0xC2E00000 (phys 0x2E00000)
  Mapped 0xC2F00000 (phys 0x2F00000)
Buddy system data area mapped successfully
Buddy System will use direct mapping (PHYS_TO_VIRT) instead of pre-mapping
Virtual address layout:
  User space:   0x00000000 - 0xBFFFFFFF (0-3GB)
  Kernel space: 0xC0000000 - 0xFFFFFFFF (3-4GB)
    Identity mapped: 0xC0000000 - 0xC07FFFFF (first 8MB)
    Direct mapping:  0xC0800000+ (computed as KERNEL_VIRT_BASE + phys)
Multiboot2 info: mem_lower=639 KB, mem_upper=523136 KB
Initializing memory management...
mm_init: starting memory management initialization
mm_init: detected 510 MB physical memory (mem_upper=523136 KB)
mm_init: initializing physical memory manager...
pmm_init: kernel_end_phys=0x3B0000
pmm_init: placing buddy system data at 16MB (0x1000000)
pmm_init: page tables will be created on-demand when accessing 0xC1000000+
pmm_init: buddy system data size: 20 MB at 0x1000000-0x2400000
pmm_init: buddy system data structures for 475 MB:
  max_blocks=121748, buddy_data_size=1 MB (1949696 bytes)
pmm_init: buddy_data_virt=0xC1000000 (will be mapped on-demand)
pmm_init: physical memory manager initialized
  start: 0x2400000 (36 MB), end: 0x1FF7FFFF (511 MB)
  total pages: 121728 (475 MB)
pmm_init: initializing buddy system...
  base_page=9216, managed_pages=121728, max_order=16
pmm_init: reserving 128 MB for kernel (pages 9216-41983)
buddy_init: base_page=9216, total_pages=121728, max_order=16
buddy_init: kernel_reserved_pages=32768 (128 MB)
buddy_init: using pre-allocated memory at 0xC1000000
buddy_init: max_blocks=121744, sizeof(buddy_block_t)=12
buddy_init: blocks_size=1460928, freelists_size=68, nextfree_size=486976
buddy_init: buddy_blocks_array=?
buddy_init: free_lists_array=?
buddy_init: next_free_array=?
buddy_init: skipping write test, proceeding to memset...
buddy_init: before memset free_lists
buddy_init: before memset next_free
buddy_init: after memset
buddy_init: creating initial free blocks
buddy_init: initialized 1 block (order 16 = 65536 pages)
buddy_init: SUCCESS - buddy system ready
pmm_init: buddy system enabled successfully
mm_init: basic memory detection complete (buddy system disabled)
mm_init: memory management initialization complete
Memory management initialized
After mm_init, before hardware init
---lapic_addr value is 0xFEE00000---
---lapic value is 0xFEE00000---
no Identity mapped---------
Allocating new page table for directory entry 770
alloc_page_table: virt=0xC0800000, phys=0xFEE00000, pd_idx=770
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x208000, virt=0xC0208000
  Allocated PT at phys=0x208000
  Writing PDE: pd[770] = 0x208003
  pd[770] now = 0x208003
  pt_virt = 0xC0208000 (from pd[770]=0x208003)
  Clearing page table...
  Filling PTEs: phys=0xFEE00000 -> virt=0xC0800000
  Flushing TLB for virt=0xC0800000
  Done!
Allocated new page table for directory entry 0xC0800000
Allocated new page table for directory entry 0xC0800000
phys_addr is 0xFEE00000
virt_addr is 0xC0800000
pte is 0x0
Mapped highmem: phys 0xFEE00000 -> virt 0xC0800000 (size: 4)
Before seginit
After seginit
Before tss_init
tss_init: starting
tss address: 0xC0109B50, sizeof(tss): 108
tss_init: before memset, will write 108 bytes
tss_init: after memset
TSS init: addr=0xC0109B50, ESP0=0xC03AFF88
TSS init:selector=0x28 
TSS loaded into task register
After tss_init
Before tvinit
[tvinit] System call gate (IDT[128]):
  offset=0xC010748F, seg=0x8, type=15, dpl=3, present=1
  vector128 address=0x?
After tvinit
segment idt init is ok
Global interrupts enabled
[KBD] Controller initialized, config=0x61
Keyboard driver initialized
Initializing file system...
[fs] Initializing file system...
[ramfs] Mounting ramfs...
[ramfs] Allocated inode: ino=1, mode=0x41C0
[ramfs] Mounted successfully, root_ino=1
[fs] File system initialized
File system initialized
PIC initial mask: 0xB8
PIC new mask: 0xB8 (verified)
Keyboard IRQ1 enabled via PIC (mask & 0x02 = 0)
Keyboard status port: 0x1C
VGA test: wrote TEST to screen at position 10-13

=== VBE/Framebuffer Detection (Multiboot2) ===
âœ“ Framebuffer info available!
  framebuffer_addr:   0x?lx
  framebuffer_pitch:  0
  framebuffer_width:  160
  framebuffer_height: 80
  framebuffer_bpp:    25
  framebuffer_type:   0
=============================================

task init
[init_task] kstack virt=0xC02A51E0
[task_load] user task: cr3=NULL (will be set by task_prepare_pde)
start user task 
Tag 0: type=21, size=12
Tag 1: type=1, size=9
Tag 2: type=2, size=29
Tag 3: type=10, size=28
Tag 4: type=3, size=17
mod 0: start=0x3D0000 end=0x3D2E24 cmdline=
Tag 5: type=6, size=160
Tag 6: type=9, size=780
Tag 7: type=4, size=16
Tag 8: type=5, size=20
Tag 9: type=8, size=32
Tag 10: type=14, size=28
[user_task_main] START: th=0xC02A41E0
User task started (task=0xC02A41E0)
[user_task_main] Calling task_prepare_pde for th=0xC02A41E0
[task_prepare_pde] START for task=0xC02A41E0
[task_prepare_pde] User task using kernel CR3: 0x101000 (shared with all)
[task_prepare_pde] task->pde=0x101000 (kernel page directory)
[task_prepare_pde] Calling load_module_to_user...
[load_module_to_user] Starting...
[load_module_to_user] Module: start=0x3D0000 end=0x3D2E24 size=0x2E24 cmdline=
[load_module_to_user] Raw physical bytes at 0x3D0000: ?2x ?2x ?2x ?2x
[load_module_to_user] ELF header at virtual 0xC03D0000
[load_module_to_user] First 4 bytes: 0x7F 0x45 0x4C 0x46
[load_module_to_user] ELF file validated!
[load_module_to_user] e_entry=0x8000143, e_phoff=52, e_phnum=3
[load_module_to_user] Program Header 0: p_type=0x1
[load_module_to_user] PT_LOAD: va=0x8000000, file_pa=0x3D1000, memsz=0x94C, filesz=0x94C
[load_module_to_user] Starting page mapping loop...
[load_module_to_user] Loop: off=0, dst_va=0x8000000
[load_module_to_user] Copied 0x94C bytes from ELF to new page
[load_module_to_user] Calling map_page: dst_va=0x8000000 dst_pa=0x2401000
[map_page] vaddr=0x8000000 new PT at phys=0x2402000
[map_page] Set pd_user[32]=0x2402007
[map_page] Set pt[0]=0x2401007 (vaddr=0x8000000 -> paddr=0x2401000)
[load_module_to_user] Page mapping loop done.
[load_module_to_user] Program Header 1: p_type=0x4
[load_module_to_user] Program Header 2: p_type=0x6474E551
[load_module_to_user] Set tf->eip = 0x8000143 (from ELF entry)
[load_module_to_user] Set segment registers: CS=0x1B, DS/ES/FS/GS/SS=0x23
[load_module_to_user] Set tf->eflags = 0x200
[load_module_to_user] Mapping user stack (4 pages)...
[load_module_to_user] Allocated stack page 0: phys=0x2403000
[load_module_to_user] Mapping stack page: va=0xBFFFF000 -> pa=0x2403000
[map_page] vaddr=0xBFFFF000 new PT at phys=0x2404000
[map_page] Set pd_user[767]=0x2404007
[map_page] Set pt[1023]=0x2403007 (vaddr=0xBFFFF000 -> paddr=0x2403000)
[load_module_to_user] Allocated stack page 1: phys=0x2405000
[load_module_to_user] Mapping stack page: va=0xBFFFE000 -> pa=0x2405000
[map_page] vaddr=0xBFFFE000 reusing existing pd_user[767]=0x2404007
[map_page] Set pt[1022]=0x2405007 (vaddr=0xBFFFE000 -> paddr=0x2405000)
[load_module_to_user] Allocated stack page 2: phys=0x2406000
[load_module_to_user] Mapping stack page: va=0xBFFFD000 -> pa=0x2406000
[map_page] vaddr=0xBFFFD000 reusing existing pd_user[767]=0x2404007
[map_page] Set pt[1021]=0x2406007 (vaddr=0xBFFFD000 -> paddr=0x2406000)
[load_module_to_user] Allocated stack page 3: phys=0x2407000
[load_module_to_user] Mapping stack page: va=0xBFFFC000 -> pa=0x2407000
[map_page] vaddr=0xBFFFC000 reusing existing pd_user[767]=0x2404007
[map_page] Set pt[1020]=0x2407007 (vaddr=0xBFFFC000 -> paddr=0x2407000)
[load_module_to_user] User stack mapping complete.
[load_module_to_user] Set task->user_stack = 0x2403000 (physical address of stack top)
[load_module_to_user] Set up user stack ABI (Linux standard):
  argc=0 at [ESP]=0xBFFFEFFC
  argv[0]=NULL at [ESP+4]=0xBFFFF000
  Stack protected with 32 NULL dwords (128 bytes) below stack_top
[load_module_to_user] Trapframe setup:
  eip=0x8000143, esp=0xBFFFEFFC
  cs=0x1B, ss=0x23, ds=0x23, eflags=0x200
[task_prepare_pde] load_module_to_user returned, checking EIP...
[task_prepare_pde] task->tf=0xC02A5194, task->tf->eip=0x8000143
[task_prepare_pde] Verifying trapframe:
  eip=0x8000143, cs=0x1B, eflags=0x200, esp=0xBFFFEFFC
[task_prepare_pde] User stack already mapped by load_module_to_user (4 pages = 16KB)
[task_prepare_pde] User stack VA range: 0xBFFFB000 - 0xBFFFF000
[task_prepare_pde] Keeping tf->esp=0xBFFFEFFC (set by load_module_to_user)
[task_prepare_pde] This ESP points to argc, following Linux ABI standard
[user_task_main] Initialization complete, returning to scheduler
[start_task] DEBUG: pid=1, first_task=0xC02A41E0, current_task[0]=0xC02A41E0
[start_task] Added task pid=1 to chain: prev->pid=1, next->pid=1
[kernel_main] User task initialized, state=PS_CREATED
user task 0xC02A41E0 kernel task 0x0
Starting scheduler with multiple tasks...
[schedule] ENTRY - schedule() called!
[schedule] Initialized schedule_switch_to_return_addr=0xC0112921
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=1, state=64, user_stack=0x2403000
[pick_next_task_cfs] current->next=0xC02A41E0
[pick_next_task_cfs] no other task, keeping current: pid=1
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2403000, state=64)
[schedule] First time entering user mode for pid=1
[schedule] About to call task_to_user_mode_with_task, next=0xC02A41E0
[task_to_user_mode_wrapper] ENTRY: task=0xC02A41E0
[task_to_user_mode_wrapper] task=0xC02A41E0, pid=1
[task_to_user_mode_wrapper] task->tf=0xC02A5194
[task_to_user_mode_wrapper] trapframe content:
  eip=0x8000143, cs=0x1B, eflags=0x200
  esp=0xBFFFEFFC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC02A41E0 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC02A41E0
[syscall] SYS_PUTCHAR: char=0x53 ('S')
S[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x74 ('t')
t[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x61 ('a')
a[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x72 ('r')
r[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x74 ('t')
t[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0xA ('
')

[syscall] SYS_PUTCHAR: done, eax=0
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A41E0, parent->tf=0xC02A5194, parent->kstack=0xC02A51E0
[do_fork] Temporarily switched CR3: 0x101000 -> 0x101003
[do_fork] Mapping child task struct to kernel page table: phys=0x2408000, virt=0xC2408000
[map_page] vaddr=0xC2408000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[8]=0x2408003 (vaddr=0xC2408000 -> paddr=0x2408000)
[do_fork] Child task struct mapped
[do_fork] Child task struct virt=0xC2408000, kstack_phys=0x2409000, kstack_virt=0xC2409000, esp=0xC240A000
[do_fork] Mapping child kstack to kernel page table: phys=0x2409000, virt=0xC2409000
[map_page] vaddr=0xC2409000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[9]=0x2409003 (vaddr=0xC2409000 -> paddr=0x2409000)
[do_fork] Child kernel stack mapped to kernel page table
[do_fork] Creating independent page directory for child...
[do_fork] Allocated child PD: phys=0x240A000, virt=0xC240A000
[do_fork] Copied kernel mappings (768-1023)
[do_fork] memcpy: parent_pt_virt=0xC2402000, child_pt_virt=0xC240B000
[do_fork] Copied PD[32]: parent_pt=0x2402000 -> child_pt=0x240B000
[do_fork] memcpy: parent_pt_virt=0xC2404000, child_pt_virt=0xC240C000
[do_fork] Copied PD[767]: parent_pt=0x2404000 -> child_pt=0x240C000
[do_fork] Copied user space page tables (0-767)
[do_fork] Child using independent CR3: 0x240A000
[do_fork] DEBUG: child task struct addr=0xC2408000
[do_fork] DEBUG: &child->tf=0xC2408098, offset=152
[do_fork] DEBUG: child->tf=0xC2409FB4 (value stored)
[do_fork] Before memcpy: child->tf=0xC2409FB4, parent->tf=0xC02A5194, size=76
[do_fork] Trapframe copied successfully
[do_fork] Trapframe copied: eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Parent tf at 0xC02A5194, Child tf at 0xC2409FB4, sizeof(tf)=76
[do_fork] Child trapfield DUMP:
  eip=0x80002A3, cs=0x1B, eflags=0x282
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0, ebx=0xA, ecx=0x0, edx=0x0
  esi=0x0, edi=0x0, ebp=0xBFFFEFF8
[do_fork] Child sharing parent's address space (including user stack)
[do_fork] âš ï¸ WARNING: Multiple children will overwrite each other's user stack!
[do_fork] âš ï¸ TODO: Implement COW (Copy-On-Write) mechanism
[do_fork] Child trapframe ready: tf=0xC2409FB4, eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Child will enter user mode via task_to_user_mode_with_task
[do_fork] Found first_task: pid=1
[do_fork] Added child to circular list: prev->pid=1, next->pid=1
[do_fork] Child PID=2 created successfully, state=64 (PS_CREATED)
[do_fork] Restored CR3: 0x101003 -> 0x101000
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A41E0, parent->tf=0xC02A5194, parent->kstack=0xC02A51E0
[do_fork] Temporarily switched CR3: 0x101000 -> 0x101003
[do_fork] Mapping child task struct to kernel page table: phys=0x240D000, virt=0xC240D000
[map_page] vaddr=0xC240D000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[13]=0x240D003 (vaddr=0xC240D000 -> paddr=0x240D000)
[do_fork] Child task struct mapped
[do_fork] Child task struct virt=0xC240D000, kstack_phys=0x240E000, kstack_virt=0xC240E000, esp=0xC240F000
[do_fork] Mapping child kstack to kernel page table: phys=0x240E000, virt=0xC240E000
[map_page] vaddr=0xC240E000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[14]=0x240E003 (vaddr=0xC240E000 -> paddr=0x240E000)
[do_fork] Child kernel stack mapped to kernel page table
[do_fork] Creating independent page directory for child...
[do_fork] Allocated child PD: phys=0x240F000, virt=0xC240F000
[do_fork] Copied kernel mappings (768-1023)
[do_fork] memcpy: parent_pt_virt=0xC2402000, child_pt_virt=0xC2410000
[do_fork] Copied PD[32]: parent_pt=0x2402000 -> child_pt=0x2410000
[do_fork] memcpy: parent_pt_virt=0xC2404000, child_pt_virt=0xC2411000
[do_fork] Copied PD[767]: parent_pt=0x2404000 -> child_pt=0x2411000
[do_fork] Copied user space page tables (0-767)
[do_fork] Child using independent CR3: 0x240F000
[do_fork] DEBUG: child task struct addr=0xC240D000
[do_fork] DEBUG: &child->tf=0xC240D098, offset=152
[do_fork] DEBUG: child->tf=0xC240EFB4 (value stored)
[do_fork] Before memcpy: child->tf=0xC240EFB4, parent->tf=0xC02A5194, size=76
[do_fork] Trapframe copied successfully
[do_fork] Trapframe copied: eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Parent tf at 0xC02A5194, Child tf at 0xC240EFB4, sizeof(tf)=76
[do_fork] Child trapfield DUMP:
  eip=0x80002A3, cs=0x1B, eflags=0x202
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0, ebx=0xA, ecx=0x0, edx=0x0
  esi=0x0, edi=0x0, ebp=0xBFFFEFF8
[do_fork] Child sharing parent's address space (including user stack)
[do_fork] âš ï¸ WARNING: Multiple children will overwrite each other's user stack!
[do_fork] âš ï¸ TODO: Implement COW (Copy-On-Write) mechanism
[do_fork] Child trapframe ready: tf=0xC240EFB4, eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Child will enter user mode via task_to_user_mode_with_task
[do_fork] Found first_task: pid=1
[do_fork] Added child to circular list: prev->pid=2, next->pid=1
[do_fork] Child PID=3 created successfully, state=64 (PS_CREATED)
[do_fork] Restored CR3: 0x101003 -> 0x101000
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A41E0, parent->tf=0xC02A5194, parent->kstack=0xC02A51E0
[do_fork] Temporarily switched CR3: 0x101000 -> 0x101003
[do_fork] Mapping child task struct to kernel page table: phys=0x2412000, virt=0xC2412000
[map_page] vaddr=0xC2412000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[18]=0x2412003 (vaddr=0xC2412000 -> paddr=0x2412000)
[do_fork] Child task struct mapped
[do_fork] Child task struct virt=0xC2412000, kstack_phys=0x2413000, kstack_virt=0xC2413000, esp=0xC2414000
[do_fork] Mapping child kstack to kernel page table: phys=0x2413000, virt=0xC2413000
[map_page] vaddr=0xC2413000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[19]=0x2413003 (vaddr=0xC2413000 -> paddr=0x2413000)
[do_fork] Child kernel stack mapped to kernel page table
[do_fork] Creating independent page directory for child...
[do_fork] Allocated child PD: phys=0x2414000, virt=0xC2414000
[do_fork] Copied kernel mappings (768-1023)
[do_fork] memcpy: parent_pt_virt=0xC2402000, child_pt_virt=0xC2415000
[do_fork] Copied PD[32]: parent_pt=0x2402000 -> child_pt=0x2415000
[do_fork] memcpy: parent_pt_virt=0xC2404000, child_pt_virt=0xC2416000
[do_fork] Copied PD[767]: parent_pt=0x2404000 -> child_pt=0x2416000
[do_fork] Copied user space page tables (0-767)
[do_fork] Child using independent CR3: 0x2414000
[do_fork] DEBUG: child task struct addr=0xC2412000
[do_fork] DEBUG: &child->tf=0xC2412098, offset=152
[do_fork] DEBUG: child->tf=0xC2413FB4 (value stored)
[do_fork] Before memcpy: child->tf=0xC2413FB4, parent->tf=0xC02A5194, size=76
[do_fork] Trapframe copied successfully
[do_fork] Trapframe copied: eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Parent tf at 0xC02A5194, Child tf at 0xC2413FB4, sizeof(tf)=76
[do_fork] Child trapfield DUMP:
  eip=0x80002A3, cs=0x1B, eflags=0x206
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0, ebx=0xA, ecx=0x0, edx=0x0
  esi=0x0, edi=0x0, ebp=0xBFFFEFF8
[do_fork] Child sharing parent's address space (including user stack)
[do_fork] âš ï¸ WARNING: Multiple children will overwrite each other's user stack!
[do_fork] âš ï¸ TODO: Implement COW (Copy-On-Write) mechanism
[do_fork] Child trapframe ready: tf=0xC2413FB4, eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Child will enter user mode via task_to_user_mode_with_task
[do_fork] Found first_task: pid=1
[do_fork] Added child to circular list: prev->pid=3, next->pid=1
[do_fork] Child PID=4 created successfully, state=64 (PS_CREATED)
[do_fork] Restored CR3: 0x101003 -> 0x101000
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A41E0, parent->tf=0xC02A5194, parent->kstack=0xC02A51E0
[do_fork] Temporarily switched CR3: 0x101000 -> 0x101003
[do_fork] Mapping child task struct to kernel page table: phys=0x2417000, virt=0xC2417000
[map_page] vaddr=0xC2417000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[23]=0x2417003 (vaddr=0xC2417000 -> paddr=0x2417000)
[do_fork] Child task struct mapped
[do_fork] Child task struct virt=0xC2417000, kstack_phys=0x2418000, kstack_virt=0xC2418000, esp=0xC2419000
[do_fork] Mapping child kstack to kernel page table: phys=0x2418000, virt=0xC2418000
[map_page] vaddr=0xC2418000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[24]=0x2418003 (vaddr=0xC2418000 -> paddr=0x2418000)
[do_fork] Child kernel stack mapped to kernel page table
[do_fork] Creating independent page directory for child...
[do_fork] Allocated child PD: phys=0x2419000, virt=0xC2419000
[do_fork] Copied kernel mappings (768-1023)
[do_fork] memcpy: parent_pt_virt=0xC2402000, child_pt_virt=0xC241A000
[do_fork] Copied PD[32]: parent_pt=0x2402000 -> child_pt=0x241A000
[do_fork] memcpy: parent_pt_virt=0xC2404000, child_pt_virt=0xC241B000
[do_fork] Copied PD[767]: parent_pt=0x2404000 -> child_pt=0x241B000
[do_fork] Copied user space page tables (0-767)
[do_fork] Child using independent CR3: 0x2419000
[do_fork] DEBUG: child task struct addr=0xC2417000
[do_fork] DEBUG: &child->tf=0xC2417098, offset=152
[do_fork] DEBUG: child->tf=0xC2418FB4 (value stored)
[do_fork] Before memcpy: child->tf=0xC2418FB4, parent->tf=0xC02A5194, size=76
[do_fork] Trapframe copied successfully
[do_fork] Trapframe copied: eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Parent tf at 0xC02A5194, Child tf at 0xC2418FB4, sizeof(tf)=76
[do_fork] Child trapfield DUMP:
  eip=0x80002A3, cs=0x1B, eflags=0x202
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0, ebx=0xA, ecx=0x0, edx=0x0
  esi=0x0, edi=0x0, ebp=0xBFFFEFF8
[do_fork] Child sharing parent's address space (including user stack)
[do_fork] âš ï¸ WARNING: Multiple children will overwrite each other's user stack!
[do_fork] âš ï¸ TODO: Implement COW (Copy-On-Write) mechanism
[do_fork] Child trapframe ready: tf=0xC2418FB4, eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Child will enter user mode via task_to_user_mode_with_task
[do_fork] Found first_task: pid=1
[do_fork] Added child to circular list: prev->pid=4, next->pid=1
[do_fork] Child PID=5 created successfully, state=64 (PS_CREATED)
[do_fork] Restored CR3: 0x101003 -> 0x101000
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[PF] fault_addr=0x0 err=0x5 eip=0x0
[PF] User task page fault, terminating
[do_exit] Task 1 exiting with code -1
[do_exit] Freeing user stack at 0x2403000 (virt)
[do_exit] Trapframe was at 0xC02A5194 (will be freed with kstack)
[do_exit] Kernel stack at 0xC02A51E0 (keeping for now)
[do_exit] Task 1 marked as terminated
[schedule] ENTRY - schedule() called!
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x86
[pick_next_task_cfs] current: pid=1, state=2, user_stack=0x0
[pick_next_task_cfs] current->next=0xC2408000
[pick_next_task_cfs] [0] checking next: pid=2, state=64, user_stack=0x2403000, can_schedule=1
[pick_next_task_cfs] selected next: pid=2
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2403000, state=64)
[schedule] First time entering user mode for pid=2
[schedule] About to call task_to_user_mode_with_task, next=0xC2408000
[task_to_user_mode_wrapper] ENTRY: task=0xC2408000
[task_to_user_mode_wrapper] task=0xC2408000, pid=2
[task_to_user_mode_wrapper] task->tf=0xC2409FB4
[task_to_user_mode_wrapper] trapframe content:
  eip=0x80002A3, cs=0x1B, eflags=0x282
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC2408000 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC2408000
[syscall] SYS_PUTCHAR: char=0x50 ('P')
P[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x34 ('4')
4[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x2D ('-')
-[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x30 ('0')
0[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x20 (' ')
 [syscall] SYS_PUTCHAR: done, eax=0
[schedule] ENTRY - schedule() called!
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=2, state=1, user_stack=0x2403000
[pick_next_task_cfs] current->next=0xC240D000
[pick_next_task_cfs] [0] checking next: pid=3, state=64, user_stack=0x2403000, can_schedule=1
[pick_next_task_cfs] selected next: pid=3
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2403000, state=64)
[schedule] First time entering user mode for pid=3
[schedule] About to call task_to_user_mode_with_task, next=0xC240D000
[task_to_user_mode_wrapper] ENTRY: task=0xC240D000
[task_to_user_mode_wrapper] task=0xC240D000, pid=3
[task_to_user_mode_wrapper] task->tf=0xC240EFB4
[task_to_user_mode_wrapper] trapframe content:
  eip=0x80002A3, cs=0x1B, eflags=0x202
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC240D000 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC240D000
[syscall] SYS_PUTCHAR: char=0x50 ('P')
P[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x34 ('4')
4[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x2D ('-')
-[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x30 ('0')
0[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x20 (' ')
 [syscall] SYS_PUTCHAR: done, eax=0
[schedule] ENTRY - schedule() called!
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=3, state=1, user_stack=0x2403000
[pick_next_task_cfs] current->next=0xC2412000
[pick_next_task_cfs] [0] checking next: pid=4, state=64, user_stack=0x2403000, can_schedule=1
[pick_next_task_cfs] selected next: pid=4
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2403000, state=64)
[schedule] First time entering user mode for pid=4
[schedule] About to call task_to_user_mode_with_task, next=0xC2412000
[task_to_user_mode_wrapper] ENTRY: task=0xC2412000
[task_to_user_mode_wrapper] task=0xC2412000, pid=4
[task_to_user_mode_wrapper] task->tf=0xC2413FB4
[task_to_user_mode_wrapper] trapframe content:
  eip=0x80002A3, cs=0x1B, eflags=0x206
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC2412000 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC2412000
[syscall] SYS_PUTCHAR: char=0x50 ('P')
P[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x34 ('4')
4[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x2D ('-')
-[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x30 ('0')
0[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x20 (' ')
 [syscall] SYS_PUTCHAR: done, eax=0
[schedule] ENTRY - schedule() called!
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=4, state=1, user_stack=0x2403000
[pick_next_task_cfs] current->next=0xC2417000
[pick_next_task_cfs] [0] checking next: pid=5, state=64, user_stack=0x2403000, can_schedule=1
[pick_next_task_cfs] selected next: pid=5
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2403000, state=64)
[schedule] First time entering user mode for pid=5
[schedule] About to call task_to_user_mode_with_task, next=0xC2417000
[task_to_user_mode_wrapper] ENTRY: task=0xC2417000
[task_to_user_mode_wrapper] task=0xC2417000, pid=5
[task_to_user_mode_wrapper] task->tf=0xC2418FB4
[task_to_user_mode_wrapper] trapframe content:
  eip=0x80002A3, cs=0x1B, eflags=0x202
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC2417000 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC2417000
[syscall] SYS_PUTCHAR: char=0x50 ('P')
P[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x34 ('4')
4[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x2D ('-')
-[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x30 ('0')
0[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x20 (' ')
 [syscall] SYS_PUTCHAR: done, eax=0
[schedule] ENTRY - schedule() called!
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=5, state=1, user_stack=0x2403000
[pick_next_task_cfs] current->next=0xC02A41E0
[pick_next_task_cfs] [0] checking next: pid=1, state=2, user_stack=0x0, can_schedule=0
[pick_next_task_cfs] skipping kernel task pid=1 (no user_stack)
[pick_next_task_cfs] [1] checking next: pid=2, state=0, user_stack=0x2403000, can_schedule=1
[pick_next_task_cfs] selected next: pid=2
[schedule] first_time_user=0, switch_to_user=0 (user_stack=0x2403000, state=0)
[schedule] CPU0: switch from task_5 to task_2
c[?7l[2J[0mSeaBIOS (version 1.16.3-debian-1.16.3-2)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1EFCAF60+1EF0AF60 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from Hard Disk...
GRUB [01;01H[2J[02;30HGNU GRUB  version 2.12[04;02Hâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[04;18H[04;19Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”[05;02Hâ”‚[05;79Hâ”‚[06;02Hâ”‚[06;79Hâ”‚[07;02Hâ”‚[07;79Hâ”‚[07;79H[08;02Hâ”‚[08;79Hâ”‚[09;02Hâ”‚[09;79Hâ”‚[10;02Hâ”‚[10;79Hâ”‚[11;02Hâ”‚[11;79Hâ”‚[12;02Hâ”‚[12;79Hâ”‚[13;02Hâ”‚[13;02H[13;79Hâ”‚[14;02Hâ”‚[14;79Hâ”‚[15;02Hâ”‚[15;79Hâ”‚[16;02Hâ”‚[16;79Hâ”‚[17;02Hâ”‚[17;79Hâ”‚[18;02Hâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[18;29H[18;30Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[18;53H[18;54Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[18;75H[18;76Hâ”€â”€â”€â”˜[20;02H     Use the â†‘ and â†“ ke[20;24H[20;25Hys to select which entry is highli[20;58H[20;59Hghted.          
 [21;02H     Press enter to boot the[21;29H[21;30H selected OS, `e' to edit the commands       
      before booting or `c' [22;28H[22;29Hfor a command-line.                     [22;68H[22;69H      [05;80H [05;03H My OS - Direct Write Test                  [05;46H[05;47H                               [05;77H[05;78H [06;03H My OS - Simple printf Test                                                 [07;03H[0;30;47m*My OS - 5 Process Test  [07;27H[07;28H                   [07;46H[07;47H                         [07;71H[07;72H       [08;03H[0m My OS - sh[08;13H[08;14Hell_demo Te[08;24H[08;25Hst                              [08;56H[08;57H                      [09;03H My OS - Simpl[09;16H[09;17He Syscall Test                          [09;56H[09;57H                      [10;03H My OS - File [10;16H[10;17HSystem Test                                                   [11;03H                         [11;27H[11;28H                                                   [12;03H            [12;14H[12;15H                                                  [12;64H[12;65H              [13;03H                                             [13;47H[13;48H                               [14;03H      [14;08H[14;09H                                       [14;47H[14;48H                               [15;03H                           [15;29H[15;30H                                                 [16;03H                                                                            [17;03H           [17;13H[17;14H                                   [17;48H[17;49H                              [17;80H 





   The highlighted[23;18H[23;19H entry will be exe[23;36H[23;37Hcuted automatically in 5s.                 [07;78H















   The highlighted entry will be executed automatically in 4s.                 [07;78H















   Th[23;05H[23;06He highlighted entry will be executed automatically in 3s.                 [07;78H















   The highl[23;12H[23;13Highted entry will be executed automatically in[23;58H[23;59H 2s.                 [07;78H















   The highlighted [23;19H[23;20Hentry will be executed aut[23;45H[23;46Homatically in 1s. [23;63H[23;64H [23;64H[23;65H   [23;67H[23;68H [23;68H[23;69H           [07;78H















 [23;02H  The highlight[23;16H[23;17Hed entry will[23;29H[23;30H be executed au[23;44H[23;45Htomatically in 0s.    [23;66H[23;67H             [01;01H[2J[2J[kernel_main] Saved kernel CR3 phys=0x101000
=== Serial initialized ===
Kernel Booted with Multiboot 2!
Magic: 0x36D76289
Info addr: 0x106010
cpuid is 0 
lapicid is 0 
 ---IOAPIC ---
ioapicid is 0 
ioapic addr is is 0xFEC00000 
Highmem mapping initialized
Identity mapped: 0xC0000000-0xC03FFFFF
Mapping buddy system metadata area (phys 16MB-48MB, 32MB total)...
Allocating new page table for directory entry 772
alloc_page_table: virt=0xC1000000, phys=0x1000000, pd_idx=772
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x200000, virt=0xC0200000
  Allocated PT at phys=0x200000
  Writing PDE: pd[772] = 0x200003
  pd[772] now = 0x200003
  pt_virt = 0xC0200000 (from pd[772]=0x200003)
  Clearing page table...
  Filling PTEs: phys=0x1000000 -> virt=0xC1000000
  Flushing TLB for virt=0xC1000000
  Done!
Allocated new page table for directory entry 0xC1000000
Allocated new page table for directory entry 0xC1000000
phys_addr is 0x1000000
virt_addr is 0xC1000000
pte is 0x110
  Mapped 0xC1000000 (phys 0x1000000)
  Mapped 0xC1100000 (phys 0x1100000)
  Mapped 0xC1200000 (phys 0x1200000)
  Mapped 0xC1300000 (phys 0x1300000)
Allocating new page table for directory entry 773
alloc_page_table: virt=0xC1400000, phys=0x1400000, pd_idx=773
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x201000, virt=0xC0201000
  Allocated PT at phys=0x201000
  Writing PDE: pd[773] = 0x201003
  pd[773] now = 0x201003
  pt_virt = 0xC0201000 (from pd[773]=0x201003)
  Clearing page table...
  Filling PTEs: phys=0x1400000 -> virt=0xC1400000
  Flushing TLB for virt=0xC1400000
  Done!
Allocated new page table for directory entry 0xC1400000
Allocated new page table for directory entry 0xC1400000
phys_addr is 0x1400000
virt_addr is 0xC1400000
pte is 0x0
  Mapped 0xC1400000 (phys 0x1400000)
  Mapped 0xC1500000 (phys 0x1500000)
  Mapped 0xC1600000 (phys 0x1600000)
  Mapped 0xC1700000 (phys 0x1700000)
Allocating new page table for directory entry 774
alloc_page_table: virt=0xC1800000, phys=0x1800000, pd_idx=774
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x202000, virt=0xC0202000
  Allocated PT at phys=0x202000
  Writing PDE: pd[774] = 0x202003
  pd[774] now = 0x202003
  pt_virt = 0xC0202000 (from pd[774]=0x202003)
  Clearing page table...
  Filling PTEs: phys=0x1800000 -> virt=0xC1800000
  Flushing TLB for virt=0xC1800000
  Done!
Allocated new page table for directory entry 0xC1800000
Allocated new page table for directory entry 0xC1800000
phys_addr is 0x1800000
virt_addr is 0xC1800000
pte is 0x0
  Mapped 0xC1800000 (phys 0x1800000)
  Mapped 0xC1900000 (phys 0x1900000)
  Mapped 0xC1A00000 (phys 0x1A00000)
  Mapped 0xC1B00000 (phys 0x1B00000)
Allocating new page table for directory entry 775
alloc_page_table: virt=0xC1C00000, phys=0x1C00000, pd_idx=775
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x203000, virt=0xC0203000
  Allocated PT at phys=0x203000
  Writing PDE: pd[775] = 0x203003
  pd[775] now = 0x203003
  pt_virt = 0xC0203000 (from pd[775]=0x203003)
  Clearing page table...
  Filling PTEs: phys=0x1C00000 -> virt=0xC1C00000
  Flushing TLB for virt=0xC1C00000
  Done!
Allocated new page table for directory entry 0xC1C00000
Allocated new page table for directory entry 0xC1C00000
phys_addr is 0x1C00000
virt_addr is 0xC1C00000
pte is 0x0
  Mapped 0xC1C00000 (phys 0x1C00000)
  Mapped 0xC1D00000 (phys 0x1D00000)
  Mapped 0xC1E00000 (phys 0x1E00000)
  Mapped 0xC1F00000 (phys 0x1F00000)
Allocating new page table for directory entry 776
alloc_page_table: virt=0xC2000000, phys=0x2000000, pd_idx=776
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x204000, virt=0xC0204000
  Allocated PT at phys=0x204000
  Writing PDE: pd[776] = 0x204003
  pd[776] now = 0x204003
  pt_virt = 0xC0204000 (from pd[776]=0x204003)
  Clearing page table...
  Filling PTEs: phys=0x2000000 -> virt=0xC2000000
  Flushing TLB for virt=0xC2000000
  Done!
Allocated new page table for directory entry 0xC2000000
Allocated new page table for directory entry 0xC2000000
phys_addr is 0x2000000
virt_addr is 0xC2000000
pte is 0x0
  Mapped 0xC2000000 (phys 0x2000000)
  Mapped 0xC2100000 (phys 0x2100000)
  Mapped 0xC2200000 (phys 0x2200000)
  Mapped 0xC2300000 (phys 0x2300000)
Allocating new page table for directory entry 777
alloc_page_table: virt=0xC2400000, phys=0x2400000, pd_idx=777
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x205000, virt=0xC0205000
  Allocated PT at phys=0x205000
  Writing PDE: pd[777] = 0x205003
  pd[777] now = 0x205003
  pt_virt = 0xC0205000 (from pd[777]=0x205003)
  Clearing page table...
  Filling PTEs: phys=0x2400000 -> virt=0xC2400000
  Flushing TLB for virt=0xC2400000
  Done!
Allocated new page table for directory entry 0xC2400000
Allocated new page table for directory entry 0xC2400000
phys_addr is 0x2400000
virt_addr is 0xC2400000
pte is 0x0
  Mapped 0xC2400000 (phys 0x2400000)
  Mapped 0xC2500000 (phys 0x2500000)
  Mapped 0xC2600000 (phys 0x2600000)
  Mapped 0xC2700000 (phys 0x2700000)
Allocating new page table for directory entry 778
alloc_page_table: virt=0xC2800000, phys=0x2800000, pd_idx=778
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x206000, virt=0xC0206000
  Allocated PT at phys=0x206000
  Writing PDE: pd[778] = 0x206003
  pd[778] now = 0x206003
  pt_virt = 0xC0206000 (from pd[778]=0x206003)
  Clearing page table...
  Filling PTEs: phys=0x2800000 -> virt=0xC2800000
  Flushing TLB for virt=0xC2800000
  Done!
Allocated new page table for directory entry 0xC2800000
Allocated new page table for directory entry 0xC2800000
phys_addr is 0x2800000
virt_addr is 0xC2800000
pte is 0x0
  Mapped 0xC2800000 (phys 0x2800000)
  Mapped 0xC2900000 (phys 0x2900000)
  Mapped 0xC2A00000 (phys 0x2A00000)
  Mapped 0xC2B00000 (phys 0x2B00000)
Allocating new page table for directory entry 779
alloc_page_table: virt=0xC2C00000, phys=0x2C00000, pd_idx=779
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x207000, virt=0xC0207000
  Allocated PT at phys=0x207000
  Writing PDE: pd[779] = 0x207003
  pd[779] now = 0x207003
  pt_virt = 0xC0207000 (from pd[779]=0x207003)
  Clearing page table...
  Filling PTEs: phys=0x2C00000 -> virt=0xC2C00000
  Flushing TLB for virt=0xC2C00000
  Done!
Allocated new page table for directory entry 0xC2C00000
Allocated new page table for directory entry 0xC2C00000
phys_addr is 0x2C00000
virt_addr is 0xC2C00000
pte is 0x0
  Mapped 0xC2C00000 (phys 0x2C00000)
  Mapped 0xC2D00000 (phys 0x2D00000)
  Mapped 0xC2E00000 (phys 0x2E00000)
  Mapped 0xC2F00000 (phys 0x2F00000)
Buddy system data area mapped successfully
Buddy System will use direct mapping (PHYS_TO_VIRT) instead of pre-mapping
Virtual address layout:
  User space:   0x00000000 - 0xBFFFFFFF (0-3GB)
  Kernel space: 0xC0000000 - 0xFFFFFFFF (3-4GB)
    Identity mapped: 0xC0000000 - 0xC07FFFFF (first 8MB)
    Direct mapping:  0xC0800000+ (computed as KERNEL_VIRT_BASE + phys)
Multiboot2 info: mem_lower=639 KB, mem_upper=523136 KB
Initializing memory management...
mm_init: starting memory management initialization
mm_init: detected 510 MB physical memory (mem_upper=523136 KB)
mm_init: initializing physical memory manager...
pmm_init: kernel_end_phys=0x3B0000
pmm_init: placing buddy system data at 16MB (0x1000000)
pmm_init: page tables will be created on-demand when accessing 0xC1000000+
pmm_init: buddy system data size: 20 MB at 0x1000000-0x2400000
pmm_init: buddy system data structures for 475 MB:
  max_blocks=121748, buddy_data_size=1 MB (1949696 bytes)
pmm_init: buddy_data_virt=0xC1000000 (will be mapped on-demand)
pmm_init: physical memory manager initialized
  start: 0x2400000 (36 MB), end: 0x1FF7FFFF (511 MB)
  total pages: 121728 (475 MB)
pmm_init: initializing buddy system...
  base_page=9216, managed_pages=121728, max_order=16
pmm_init: reserving 128 MB for kernel (pages 9216-41983)
buddy_init: bas