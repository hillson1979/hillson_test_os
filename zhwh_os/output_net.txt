c[?7l[2J[0mSeaBIOS (version 1.16.3-debian-1.16.3-2)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1EFCAF60+1EF0AF60 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from Hard Disk...
GRUB [01;01H[2J[02;30HGNU GRUB  version 2[02;48H[02;49H.12[04;02Hâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[04;22H[04;23Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[04;46H[04;47Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[04;64H[04;65Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”[05;02Hâ”‚[05;79Hâ”‚[06;02Hâ”‚[06;02H[06;79Hâ”‚[07;02Hâ”‚[07;79Hâ”‚[08;02Hâ”‚[08;79Hâ”‚[09;02Hâ”‚[09;79Hâ”‚[10;02Hâ”‚[10;79Hâ”‚[10;79H[11;02Hâ”‚[11;79Hâ”‚[12;02Hâ”‚[12;79Hâ”‚[13;02Hâ”‚[13;79Hâ”‚[14;02Hâ”‚[14;79Hâ”‚[15;02Hâ”‚[15;79Hâ”‚[15;79H[16;02Hâ”‚[16;79Hâ”‚[17;02Hâ”‚[17;79Hâ”‚[18;02Hâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[18;16H[18;17Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜[20;02H     Use the â†‘ and â†“ [20;22H[20;23Hkeys to select which entry is[20;51H[20;52H highlighted.          
      Press enter to boot the selected OS, `e' to[21;49H[21;50H edit the commands       
      before booting or `c' for a comman[22;40H[22;41Hd-line.                          [22;73H[22;74H [05;80H [05;03H My OS - Direct Write Test    [05;32H[05;33H                                  [05;66H[05;67H            [06;03H My OS - Simple printf [06;25H[06;26HTest                                   [06;64H[06;65H              [07;03H My OS - 5 Process Test                                        [07;65H[07;66H             [08;03H My OS - shell_demo Test                                                    [09;03H My OS - Simple Syscall Test                                        [09;70H[09;71H        [10;03H[0;30;47m*My OS - File System T[10;24H[10;25Hest                                [10;59H[10;60H                   [11;03H[0m                                                                            [12;03H               [12;17H[12;18H                                       [12;56H[12;57H                      [13;03H          [13;12H[13;13H                                  [13;46H[13;47H                                [13;78H[14;03H                             [14;31H[14;32H                                     [14;68H[14;69H          [15;03H                                                                 [15;67H[15;68H           [16;03H                                                                            [17;03H                      [17;24H[17;25H                                     [17;61H[17;62H                 [17;80H 





   The highligh[23;15H[23;16Hted entry will be executed automatically in 5s.                 [10;78H












  [23;02H[23;03H The highlighted entry will be executed automatically in 4s.   [23;65H[23;66H              [10;78H












   The highlighted entr[23;23H[23;24Hy will be executed automatical[23;53H[23;54Hly in 3s.        [23;70H[23;71H         [10;78H












   The highlighted entry will be executed automatically in 2s.                 [10;78H












   The highlig[23;14H[23;15Hhted entry will be executed automat[23;49H[23;50Hicall[23;54H[23;55Hy in 1s.                 [10;78H












 [23;02H  T[23;04H[23;05Hhe high[23;11H[23;12Hl[23;12H[23;13Hight[23;16H[23;17Hed[23;18H[23;19H entry will be executed automatic[23;51H[23;52Hally in 0s.          [23;72H[23;73H       [01;01H[2J[2J[kernel_main] Saved kernel CR3 phys=0x101000
=== Serial initialized ===
Kernel Booted with Multiboot 2!
Magic: 0x36D76289
Info addr: 0x106010
cpuid is 0 
lapicid is 0 
 ---IOAPIC ---
ioapicid is 0 
ioapic addr is is 0xFEC00000 
Highmem mapping initialized
Identity mapped: 0xC0000000-0xC03FFFFF
Mapping buddy system metadata area (phys 16MB-48MB, 32MB total)...
Allocating new page table for directory entry 772
alloc_page_table: virt=0xC1000000, phys=0x1000000, pd_idx=772
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x200000, virt=0xC0200000
  Allocated PT at phys=0x200000
  Writing PDE: pd[772] = 0x200003
  pd[772] now = 0x200003
  pt_virt = 0xC0200000 (from pd[772]=0x200003)
  Clearing page table...
  Filling PTEs: phys=0x1000000 -> virt=0xC1000000
  Flushing TLB for virt=0xC1000000
  Done!
Allocated new page table for directory entry 0xC1000000
Allocated new page table for directory entry 0xC1000000
phys_addr is 0x1000000
virt_addr is 0xC1000000
pte is 0x0
  Mapped 0xC1000000 (phys 0x1000000)
  Mapped 0xC1100000 (phys 0x1100000)
  Mapped 0xC1200000 (phys 0x1200000)
  Mapped 0xC1300000 (phys 0x1300000)
Allocating new page table for directory entry 773
alloc_page_table: virt=0xC1400000, phys=0x1400000, pd_idx=773
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x201000, virt=0xC0201000
  Allocated PT at phys=0x201000
  Writing PDE: pd[773] = 0x201003
  pd[773] now = 0x201003
  pt_virt = 0xC0201000 (from pd[773]=0x201003)
  Clearing page table...
  Filling PTEs: phys=0x1400000 -> virt=0xC1400000
  Flushing TLB for virt=0xC1400000
  Done!
Allocated new page table for directory entry 0xC1400000
Allocated new page table for directory entry 0xC1400000
phys_addr is 0x1400000
virt_addr is 0xC1400000
pte is 0x0
  Mapped 0xC1400000 (phys 0x1400000)
  Mapped 0xC1500000 (phys 0x1500000)
  Mapped 0xC1600000 (phys 0x1600000)
  Mapped 0xC1700000 (phys 0x1700000)
Allocating new page table for directory entry 774
alloc_page_table: virt=0xC1800000, phys=0x1800000, pd_idx=774
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x202000, virt=0xC0202000
  Allocated PT at phys=0x202000
  Writing PDE: pd[774] = 0x202003
  pd[774] now = 0x202003
  pt_virt = 0xC0202000 (from pd[774]=0x202003)
  Clearing page table...
  Filling PTEs: phys=0x1800000 -> virt=0xC1800000
  Flushing TLB for virt=0xC1800000
  Done!
Allocated new page table for directory entry 0xC1800000
Allocated new page table for directory entry 0xC1800000
phys_addr is 0x1800000
virt_addr is 0xC1800000
pte is 0x0
  Mapped 0xC1800000 (phys 0x1800000)
  Mapped 0xC1900000 (phys 0x1900000)
  Mapped 0xC1A00000 (phys 0x1A00000)
  Mapped 0xC1B00000 (phys 0x1B00000)
Allocating new page table for directory entry 775
alloc_page_table: virt=0xC1C00000, phys=0x1C00000, pd_idx=775
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x203000, virt=0xC0203000
  Allocated PT at phys=0x203000
  Writing PDE: pd[775] = 0x203003
  pd[775] now = 0x203003
  pt_virt = 0xC0203000 (from pd[775]=0x203003)
  Clearing page table...
  Filling PTEs: phys=0x1C00000 -> virt=0xC1C00000
  Flushing TLB for virt=0xC1C00000
  Done!
Allocated new page table for directory entry 0xC1C00000
Allocated new page table for directory entry 0xC1C00000
phys_addr is 0x1C00000
virt_addr is 0xC1C00000
pte is 0x0
  Mapped 0xC1C00000 (phys 0x1C00000)
  Mapped 0xC1D00000 (phys 0x1D00000)
  Mapped 0xC1E00000 (phys 0x1E00000)
  Mapped 0xC1F00000 (phys 0x1F00000)
Allocating new page table for directory entry 776
alloc_page_table: virt=0xC2000000, phys=0x2000000, pd_idx=776
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x204000, virt=0xC0204000
  Allocated PT at phys=0x204000
  Writing PDE: pd[776] = 0x204003
  pd[776] now = 0x204003
  pt_virt = 0xC0204000 (from pd[776]=0x204003)
  Clearing page table...
  Filling PTEs: phys=0x2000000 -> virt=0xC2000000
  Flushing TLB for virt=0xC2000000
  Done!
Allocated new page table for directory entry 0xC2000000
Allocated new page table for directory entry 0xC2000000
phys_addr is 0x2000000
virt_addr is 0xC2000000
pte is 0x0
  Mapped 0xC2000000 (phys 0x2000000)
  Mapped 0xC2100000 (phys 0x2100000)
  Mapped 0xC2200000 (phys 0x2200000)
  Mapped 0xC2300000 (phys 0x2300000)
Allocating new page table for directory entry 777
alloc_page_table: virt=0xC2400000, phys=0x2400000, pd_idx=777
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x205000, virt=0xC0205000
  Allocated PT at phys=0x205000
  Writing PDE: pd[777] = 0x205003
  pd[777] now = 0x205003
  pt_virt = 0xC0205000 (from pd[777]=0x205003)
  Clearing page table...
  Filling PTEs: phys=0x2400000 -> virt=0xC2400000
  Flushing TLB for virt=0xC2400000
  Done!
Allocated new page table for directory entry 0xC2400000
Allocated new page table for directory entry 0xC2400000
phys_addr is 0x2400000
virt_addr is 0xC2400000
pte is 0x0
  Mapped 0xC2400000 (phys 0x2400000)
  Mapped 0xC2500000 (phys 0x2500000)
  Mapped 0xC2600000 (phys 0x2600000)
  Mapped 0xC2700000 (phys 0x2700000)
Allocating new page table for directory entry 778
alloc_page_table: virt=0xC2800000, phys=0x2800000, pd_idx=778
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x206000, virt=0xC0206000
  Allocated PT at phys=0x206000
  Writing PDE: pd[778] = 0x206003
  pd[778] now = 0x206003
  pt_virt = 0xC0206000 (from pd[778]=0x206003)
  Clearing page table...
  Filling PTEs: phys=0x2800000 -> virt=0xC2800000
  Flushing TLB for virt=0xC2800000
  Done!
Allocated new page table for directory entry 0xC2800000
Allocated new page table for directory entry 0xC2800000
phys_addr is 0x2800000
virt_addr is 0xC2800000
pte is 0x0
  Mapped 0xC2800000 (phys 0x2800000)
  Mapped 0xC2900000 (phys 0x2900000)
  Mapped 0xC2A00000 (phys 0x2A00000)
  Mapped 0xC2B00000 (phys 0x2B00000)
Allocating new page table for directory entry 779
alloc_page_table: virt=0xC2C00000, phys=0x2C00000, pd_idx=779
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x207000, virt=0xC0207000
  Allocated PT at phys=0x207000
  Writing PDE: pd[779] = 0x207003
  pd[779] now = 0x207003
  pt_virt = 0xC0207000 (from pd[779]=0x207003)
  Clearing page table...
  Filling PTEs: phys=0x2C00000 -> virt=0xC2C00000
  Flushing TLB for virt=0xC2C00000
  Done!
Allocated new page table for directory entry 0xC2C00000
Allocated new page table for directory entry 0xC2C00000
phys_addr is 0x2C00000
virt_addr is 0xC2C00000
pte is 0x0
  Mapped 0xC2C00000 (phys 0x2C00000)
  Mapped 0xC2D00000 (phys 0x2D00000)
  Mapped 0xC2E00000 (phys 0x2E00000)
  Mapped 0xC2F00000 (phys 0x2F00000)
Buddy system data area mapped successfully
Buddy System will use direct mapping (PHYS_TO_VIRT) instead of pre-mapping
Virtual address layout:
  User space:   0x00000000 - 0xBFFFFFFF (0-3GB)
  Kernel space: 0xC0000000 - 0xFFFFFFFF (3-4GB)
    Identity mapped: 0xC0000000 - 0xC07FFFFF (first 8MB)
    Direct mapping:  0xC0800000+ (computed as KERNEL_VIRT_BASE + phys)
Multiboot2 info: mem_lower=639 KB, mem_upper=523136 KB
Initializing memory management...
mm_init: starting memory management initialization
mm_init: detected 510 MB physical memory (mem_upper=523136 KB)
mm_init: initializing physical memory manager...
pmm_init: kernel_end_phys=0x3B2000
pmm_init: placing buddy system data at 16MB (0x1000000)
pmm_init: page tables will be created on-demand when accessing 0xC1000000+
pmm_init: buddy system data size: 20 MB at 0x1000000-0x2400000
pmm_init: buddy system data structures for 475 MB:
  max_blocks=121748, buddy_data_size=1 MB (1949696 bytes)
pmm_init: buddy_data_virt=0xC1000000 (will be mapped on-demand)
pmm_init: physical memory manager initialized
  start: 0x2400000 (36 MB), end: 0x1FF7FFFF (511 MB)
  total pages: 121728 (475 MB)
pmm_init: initializing buddy system...
  base_page=9216, managed_pages=121728, max_order=16
pmm_init: reserving 512 MB for kernel (pages 9216-140287)
buddy_init: base_page=9216, total_pages=121728, max_order=16
buddy_init: kernel_reserved_pages=131072 (512 MB)
buddy_init: using pre-allocated memory at 0xC1000000
buddy_init: max_blocks=121744, sizeof(buddy_block_t)=12
buddy_init: blocks_size=1460928, freelists_size=68, nextfree_size=486976
buddy_init: buddy_blocks_array=?
buddy_init: free_lists_array=?
buddy_init: next_free_array=?
buddy_init: skipping write test, proceeding to memset...
buddy_init: before memset free_lists
buddy_init: before memset next_free
buddy_init: after memset
buddy_init: creating initial free blocks
buddy_init: initialized 1 block (order 16 = 65536 pages)
buddy_init: SUCCESS - buddy system ready
pmm_init: buddy system enabled successfully
mm_init: basic memory detection complete (buddy system disabled)
mm_init: memory management initialization complete
Memory management initialized
After mm_init, before hardware init
---lapic_addr value is 0xFEE00000---
---lapic value is 0xFEE00000---
no Identity mapped---------
Allocating new page table for directory entry 770
alloc_page_table: virt=0xC0800000, phys=0xFEE00000, pd_idx=770
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x208000, virt=0xC0208000
  Allocated PT at phys=0x208000
  Writing PDE: pd[770] = 0x208003
  pd[770] now = 0x208003
  pt_virt = 0xC0208000 (from pd[770]=0x208003)
  Clearing page table...
  Filling PTEs: phys=0xFEE00000 -> virt=0xC0800000
  Flushing TLB for virt=0xC0800000
  Done!
Allocated new page table for directory entry 0xC0800000
Allocated new page table for directory entry 0xC0800000
phys_addr is 0xFEE00000
virt_addr is 0xC0800000
pte is 0x0
Mapped highmem: phys 0xFEE00000 -> virt 0xC0800000 (size: 4)
Before seginit
After seginit
Before tss_init
tss_init: starting
tss address: 0xC0109B50, sizeof(tss): 108
tss_init: before memset, will write 108 bytes
tss_init: after memset
TSS init: addr=0xC0109B50, ESP0=0xC03B1F88
TSS init:selector=0x28 
TSS loaded into task register
After tss_init
Before tvinit
[tvinit] System call gate (IDT[128]):
  offset=0xC010748F, seg=0x8, type=15, dpl=3, present=1
  vector128 address=0x?
After tvinit
segment idt init is ok
Global interrupts enabled
[KBD] Controller initialized, config=0x61
Keyboard driver initialized
Initializing file system...
[fs] Initializing file system...
[ramfs] Mounting ramfs...
[ramfs] Allocated inode: ino=1, mode=0x41C0
[ramfs] Mounted successfully, root_ino=1
[vfs] Root super block set: sb=0xC02A6160, root_ino=1
[fs] File system initialized
[fs] Creating test files...
[ramfs] create: dir_ino=1, name='test.txt', mode=0x81A4
[ramfs] lookup: dir_ino=1, name='test.txt'
[ramfs] lookup: not found
[ramfs] Allocated inode: ino=2, mode=0x81A4
[ramfs] create: success, inode=2
[fs] Created /test.txt
[fs] Written 39 bytes to /test.txt
[ramfs] create: dir_ino=1, name='fstest.txt', mode=0x81A4
[ramfs] lookup: dir_ino=1, name='fstest.txt'
[ramfs] lookup: not found
[ramfs] Allocated inode: ino=3, mode=0x81A4
[ramfs] create: success, inode=3
[fs] Created /fstest.txt
[fs] Written 142 bytes to /fstest.txt
[fs] Test files ready

[fs] === Kernel-level File Read Test ===
[fs] Attempting to read /test.txt...
[ramfs] read: inode=2, size=255, pos=?lu
[ramfs] read: read 39 bytes
[fs] ramfs_read returned: 39 bytes
[fs] Content of /test.txt:
[fs] >>>Hello from ramfs!
This is a test file.
<<<

[fs] Attempting to read /fstest.txt...
[ramfs] read: inode=3, size=255, pos=?lu
[ramfs] read: read 142 bytes
[fs] ramfs_read returned: 142 bytes
[fs] Content of /fstest.txt:
[fs] >>>File System Test File
=====================
This file was created during kernel initialization.
You can read it using the read() system call.
<<<
[fs] === Kernel Test Complete ===

File system initialized
[net] Initializing network stack...
[net] Network stack initialized
[net] Local IP: 192.168.1.1
[loopback] Initializing loopback device...
[net] Registered device: lo
[net]   MAC: 00:00:00:00:00:01
[loopback] Loopback device ready
Network initialized

=== Network Test ===
[loopback] Sending test packet...
[loopback] Sending 62 bytes test packet
[loopback] Sending 62 bytes
[net] Eth frame: type=0x800, len=62
[net] IP packet: proto=1, src=1.1.168.192, dst=1.1.168.192
[net] IP not for us, dropping
kfree: freeing 62 bytes (0 pages) at virt=0xC02A6510, phys=0x0
=== Network Test Complete ===

PIC initial mask: 0xB8
PIC new mask: 0xB8 (verified)
Keyboard IRQ1 enabled via PIC (mask & 0x02 = 0)
Keyboard status port: 0x1C
VGA test: wrote TEST to screen at position 10-13

=== VBE/Framebuffer Detection (Multiboot2) ===
âœ“ Framebuffer info available!
  framebuffer_addr:   0x?lx
  framebuffer_pitch:  0
  framebuffer_width:  160
  framebuffer_height: 80
  framebuffer_bpp:    25
  framebuffer_type:   0
=============================================

task init
[init_task] kstack virt=0xC02A7550
[task_load] user task: cr3=NULL (will be set by task_prepare_pde)
start user task 
Tag 0: type=21, size=12
Tag 1: type=1, size=9
Tag 2: type=2, size=29
Tag 3: type=10, size=28
Tag 4: type=3, size=17
mod 0: start=0x3D4000 end=0x3D7DD4 cmdline=
Tag 5: type=6, size=160
Tag 6: type=9, size=780
Tag 7: type=4, size=16
Tag 8: type=5, size=20
Tag 9: type=8, size=32
Tag 10: type=14, size=28
[user_task_main] START: th=0xC02A6550
User task started (task=0xC02A6550)
[user_task_main] Calling task_prepare_pde for th=0xC02A6550
[task_prepare_pde] START for task=0xC02A6550
[task_prepare_pde] User task using kernel CR3: 0x101000 (shared with all)
[task_prepare_pde] task->pde=0x101000 (kernel page directory)
[task_prepare_pde] Calling load_module_to_user...
[load_module_to_user] Starting...
[load_module_to_user] Module: start=0x3D4000 end=0x3D7DD4 size=0x3DD4 cmdline=
[load_module_to_user] Raw physical bytes at 0x3D4000: 7F 45 4C 46
[load_module_to_user] ELF header at virtual 0xC03D4000
[load_module_to_user] First 4 bytes: 0x7F 0x45 0x4C 0x46
[load_module_to_user] ELF file validated!
[load_module_to_user] e_entry=0x8000024, e_phoff=52, e_phnum=3
[load_module_to_user] Program Header 0: p_type=0x1
[load_module_to_user] PT_LOAD: va=0x8000000, file_pa=0x3D5000, memsz=0x1328, filesz=0x1328
[load_module_to_user] Starting page mapping loop...
[load_module_to_user] Loop: off=0, dst_va=0x8000000
[load_module_to_user] Copied 0x1000 bytes from ELF to new page
[load_module_to_user] Calling map_page: dst_va=0x8000000 dst_pa=0x2401000
[map_page] vaddr=0x8000000 new PT at phys=0x2402000
[map_page] Set pd_user[32]=0x2402007
[map_page] Set pt[0]=0x2401007 (vaddr=0x8000000 -> paddr=0x2401000)
[load_module_to_user] Loop: off=4096, dst_va=0x8001000
[load_module_to_user] Copied 0x328 bytes from ELF to new page
[load_module_to_user] Calling map_page: dst_va=0x8001000 dst_pa=0x2403000
[map_page] vaddr=0x8001000 reusing existing pd_user[32]=0x2402007
[map_page] Set pt[1]=0x2403007 (vaddr=0x8001000 -> paddr=0x2403000)
[load_module_to_user] Page mapping loop done.
[load_module_to_user] Program Header 1: p_type=0x4
[load_module_to_user] Program Header 2: p_type=0x6474E551
[load_module_to_user] Set tf->eip = 0x8000024 (from ELF entry)
[load_module_to_user] Set segment registers: CS=0x1B, DS/ES/FS/GS/SS=0x23
[load_module_to_user] Set tf->eflags = 0x200
[load_module_to_user] Mapping user stack (4 pages)...
[load_module_to_user] Allocated stack page 0: phys=0x2404000
[load_module_to_user] Mapping stack page: va=0xBFFFF000 -> pa=0x2404000
[map_page] vaddr=0xBFFFF000 new PT at phys=0x2405000
[map_page] Set pd_user[767]=0x2405007
[map_page] Set pt[1023]=0x2404007 (vaddr=0xBFFFF000 -> paddr=0x2404000)
[load_module_to_user] Allocated stack page 1: phys=0x2406000
[load_module_to_user] Mapping stack page: va=0xBFFFE000 -> pa=0x2406000
[map_page] vaddr=0xBFFFE000 reusing existing pd_user[767]=0x2405007
[map_page] Set pt[1022]=0x2406007 (vaddr=0xBFFFE000 -> paddr=0x2406000)
[load_module_to_user] Allocated stack page 2: phys=0x2407000
[load_module_to_user] Mapping stack page: va=0xBFFFD000 -> pa=0x2407000
[map_page] vaddr=0xBFFFD000 reusing existing pd_user[767]=0x2405007
[map_page] Set pt[1021]=0x2407007 (vaddr=0xBFFFD000 -> paddr=0x2407000)
[load_module_to_user] Allocated stack page 3: phys=0x2408000
[load_module_to_user] Mapping stack page: va=0xBFFFC000 -> pa=0x2408000
[map_page] vaddr=0xBFFFC000 reusing existing pd_user[767]=0x2405007
[map_page] Set pt[1020]=0x2408007 (vaddr=0xBFFFC000 -> paddr=0x2408000)
[load_module_to_user] User stack mapping complete.
[load_module_to_user] Set task->user_stack = 0x2404000 (physical address of stack top)
[load_module_to_user] Set up user stack ABI (Linux standard):
  argc=0 at [ESP]=0xBFFFEFFC
  argv[0]=NULL at [ESP+4]=0xBFFFF000
  Stack protected with 32 NULL dwords (128 bytes) below stack_top
[load_module_to_user] Trapframe setup:
  eip=0x8000024, esp=0xBFFFEFFC
  cs=0x1B, ss=0x23, ds=0x23, eflags=0x200
[task_prepare_pde] load_module_to_user returned, checking EIP...
[task_prepare_pde] task->tf=0xC02A7504, task->tf->eip=0x8000024
[task_prepare_pde] Verifying trapframe:
  eip=0x8000024, cs=0x1B, eflags=0x200, esp=0xBFFFEFFC
[task_prepare_pde] User stack already mapped by load_module_to_user (4 pages = 16KB)
[task_prepare_pde] User stack VA range: 0xBFFFB000 - 0xBFFFF000
[task_prepare_pde] Keeping tf->esp=0xBFFFEFFC (set by load_module_to_user)
[task_prepare_pde] This ESP points to argc, following Linux ABI standard
[user_task_main] Initialization complete, returning to scheduler
[start_task] DEBUG: pid=1, first_task=0xC02A6550, current_task[0]=0xC02A6550
[start_task] Added task pid=1 to chain: prev->pid=1, next->pid=1
[kernel_main] User task initialized, state=PS_CREATED
user task 0xC02A6550 kernel task 0x0
Starting scheduler with multiple tasks...
[schedule] ENTRY - schedule() called!
[schedule] Initialized schedule_switch_to_return_addr=0xC0112A68
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=1, state=64, user_stack=0x2404000
[pick_next_task_cfs] current->next=0xC02A6550
[pick_next_task_cfs] no other task, keeping current: pid=1
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2404000, state=64)
[schedule] First time entering user mode for pid=1
[schedule] About to call task_to_user_mode_with_task, next=0xC02A6550
[task_to_user_mode_wrapper] ENTRY: task=0xC02A6550
[task_to_user_mode_wrapper] task=0xC02A6550, pid=1
[task_to_user_mode_wrapper] task->tf=0xC02A7504
[task_to_user_mode_wrapper] trapframe content:
  eip=0x8000024, cs=0x1B, eflags=0x200
  esp=0xBFFFEFFC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC02A6550 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC02A6550
[syscall] SYS_OPEN: pathname=0x8000BFA, flags=0
[syscall] Reading from user address 0x8000BFA
[syscall] DEBUG: pathname=0x8000BFA, 0xC0000000=1
[syscall] User space address, attempting page table walk...
[syscall] pd_idx=32, pt_idx=0, offset=0xBFA
[syscall] pde_entry=0x2402027
[syscall] Page table at phys=0x2402000
no Identity mapped---------
Mapped highmem: phys 0x2402000 -> virt 0xC0801000 (size: 4096)
[syscall] pte=0x2401027
[syscall] phys_page=0x2401000
no Identity mapped---------
Mapped highmem: phys 0x2401000 -> virt 0xC0802000 (size: 4096)
[syscall] user_page_virt=0xC0802000
[syscall] Test read: user_page_virt[3066]=0x2F
[syscall] Test read: user_page_virt[3067]=0x0
[syscall] Test read: user_page_virt[3068]=0x2F
[syscall] Raw data: 2F 00 2F 6D 6E 74 2F 66 2F 68 69 6C 6C 73 6F 6E 
[syscall] Copied path: '/' (len=1)
[syscall] kpath[0]=0x2F ('/'), kpath[1]=0x0
[vfs] filp_open: filename ptr=0xC02A71CF
[vfs] filp_open: filename[0]=0x2F ('/'), filename[1]=0x0
[vfs] filp_open: '/', flags=0
[vfs] filp_open: root_sb=0xC02A6160
[vfs] path_lookup: '/'
[vfs] path_lookup: found inode=1
[ramfs] open: inode=1
[vfs] filp_open: success, inode=1
[syscall] SYS_OPEN: pathname=0x8000CCB, flags=0
[syscall] Reading from user address 0x8000CCB
[syscall] DEBUG: pathname=0x8000CCB, 0xC0000000=1
[syscall] User space address, attempting page table walk...
[syscall] pd_idx=32, pt_idx=0, offset=0xCCB
[syscall] pde_entry=0x2402027
[syscall] Page table at phys=0x2402000
no Identity mapped---------
[syscall] pte=0x2401027
[syscall] phys_page=0x2401000
no Identity mapped---------
[syscall] user_page_virt=0xC0802000
[syscall] Test read: user_page_virt[3275]=0x2F
[syscall] Test read: user_page_virt[3276]=0x74
[syscall] Test read: user_page_virt[3277]=0x65
[syscall] Raw data: 2F 74 65 73 74 2E 74 78 74 00 20 20 43 6F 6E 74 
[syscall] Copied path: '/test.txt' (len=9)
[syscall] kpath[0]=0x2F ('/'), kpath[1]=0x74
[vfs] filp_open: filename ptr=0xC02A71CF
[vfs] filp_open: filename[0]=0x2F ('/'), filename[1]=0x74
[vfs] filp_open: '/test.txt', flags=0
[vfs] filp_open: root_sb=0xC02A6160
[vfs] path_lookup: '/test.txt'
[vfs] Looking up 'test.txt' in dir_ino=1
[ramfs] lookup: dir_ino=1, name='test.txt'
[ramfs] lookup: found inode=2
[vfs] path_lookup: found inode=2
[vfs] filp_open: success, inode=2
[syscall] SYS_OPEN: pathname=0x8000D51, flags=0
[syscall] Reading from user address 0x8000D51
[syscall] DEBUG: pathname=0x8000D51, 0xC0000000=1
[syscall] User space address, attempting page table walk...
[syscall] pd_idx=32, pt_idx=0, offset=0xD51
[syscall] pde_entry=0x2402027
[syscall] Page table at phys=0x2402000
no Identity mapped---------
[syscall] pte=0x2401027
[syscall] phys_page=0x2401000
no Identity mapped---------
[syscall] user_page_virt=0xC0802000
[syscall] Test read: user_page_virt[3409]=0x2F
[syscall] Test read: user_page_virt[3410]=0x66
[syscall] Test read: user_page_virt[3411]=0x73
[syscall] Raw data: 2F 66 73 74 65 73 74 2E 74 78 74 00 00 00 00 0A 
[syscall] Copied path: '/fstest.txt' (len=11)
[syscall] kpath[0]=0x2F ('/'), kpath[1]=0x66
[vfs] filp_open: filename ptr=0xC02A71CF
[vfs] filp_open: filename[0]=0x2F ('/'), filename[1]=0x66
[vfs] filp_open: '/fstest.txt', flags=0
[vfs] filp_open: root_sb=0xC02A6160
[vfs] path_lookup: '/fstest.txt'
[vfs] Looking up 'fstest.txt' in dir_ino=1
[ramfs] lookup: dir_ino=1, name='fstest.txt'
[ramfs] lookup: found inode=3
[vfs] path_lookup: found inode=3
[vfs] filp_open: success, inode=3
[syscall] SYS_OPEN: pathname=0x8000D97, flags=0
[syscall] Reading from user address 0x8000D97
[syscall] DEBUG: pathname=0x8000D97, 0xC0000000=1
[syscall] User space address, attempting page table walk...
[syscall] pd_idx=32, pt_idx=0, offset=0xD97
[syscall] pde_entry=0x2402027
[syscall] Page table at phys=0x2402000
no Identity mapped---------
[syscall] pte=0x2401027
[syscall] phys_page=0x2401000
no Identity mapped---------
[syscall] user_page_virt=0xC0802000
[syscall] Test read: user_page_virt[3479]=0x2F
[syscall] Test read: user_page_virt[3480]=0x6E
[syscall] Test read: user_page_virt[3481]=0x6F
[syscall] Raw data: 2F 6E 6F 6E 65 78 69 73 74 65 6E 74 2E 74 78 74 
[syscall] Copied path: '/nonexistent.txt' (len=16)
[syscall] kpath[0]=0x2F ('/'), kpath[1]=0x6E
[vfs] filp_open: filename ptr=0xC02A71CF
[vfs] filp_open: filename[0]=0x2F ('/'), filename[1]=0x6E
[vfs] filp_open: '/nonexistent.txt', flags=0
[vfs] filp_open: root_sb=0xC02A6160
[vfs] path_lookup: '/nonexistent.txt'
[vfs] Looking up 'nonexistent.txt' in dir_ino=1
[ramfs] lookup: dir_ino=1, name='nonexistent.txt'
[ramfs] lookup: not found
[vfs] Path component not found: nonexistent.txt
[vfs] filp_open: file not found
[do_exit] Task 1 exiting with code 0
[do_exit] Freeing user stack at 0x2404000 (virt)
[do_exit] Trapframe was at 0xC02A7504 (will be freed with kstack)
[do_exit] Kernel stack at 0xC02A7550 (keeping for now)
[do_exit] Task 1 marked as terminated
[do_exit] No more runnable tasks, halting...
