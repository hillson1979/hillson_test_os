    // Store state for polling
    intr_state.active = 1;
    intr_state.buffer = (uint8_t *)data;
    intr_state.max_length = len;
    intr_state.bytes_transferred = 0;
    intr_state.td = td;

    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šåˆ›å»º QH å¹¶å°† TD é“¾æ¥è¿›å»ï¼
    // æ²¡æœ‰ QHï¼ŒTD æ°¸è¿œä¸ä¼šè¢« UHCI å¤„ç†
    uhci_qh_t *qh = uhci_alloc_qh(ctrl);
    if (\!qh) {
        printf("[USB] ERROR: Failed to allocate QH\n");
        return -1;
    }

    // åˆå§‹åŒ– QH
    qh->horiz_link_ptr = UHCI_LINK_TERMINATE;  // æ— æ°´å¹³é“¾æ¥
    qh->vert_link_ptr = ((uint32_t)td) | 0x02;  // æŒ‡å‘ TDï¼Œè®¾ç½® QH é€‰æ‹©ä½
    qh->curr_qh_td_ptr = 0;  // åˆå§‹æ— å½“å‰ TD

    // è®¾ç½®ç«¯ç‚¹å±æ€§
    // [11:0] = Max N-1 åŒ…å¤§å° (63 = 64 å­—èŠ‚ç”¨äºé¼ æ ‡)
    // [15:11] = è®¾å¤‡åœ°å€
    // [10:0] = ç«¯ç‚¹å·
    // [12] = F æ ‡å¿— (0 = éç­‰æ—¶)
    qh->endpoint = (63 << 5) | (dev_addr << 8) | ep;
    qh->endpoint_cap = 0;  // F = 0 (éç­‰æ—¶)
    qh->status = 0;

    // ä¿å­˜ QH æŒ‡é’ˆ
    intr_state.qh = qh;

    printf("[USB] Interrupt transfer TD=%p QH=%p (linked)\n", td, qh);
    return 0;  // Transfer initiated successfully
}

/**
 * @brief Poll for interrupt transfer completion
 *
 * æ£€æŸ¥ä¹‹å‰å¯åŠ¨çš„ä¸­æ–­ä¼ è¾“æ˜¯å¦å®Œæˆ
 *
 * @return 1 if completed with data, 0 if still pending, negative on error
 */
int usb_interrupt_poll(int controller_id) {
    if (controller_id >= num_uhci_controllers) {
        return -1;
    }

    uhci_controller_t *ctrl = &uhci_controllers[controller_id];
    if (\!ctrl->initialized) {
        return -1;
    }

    if (\!intr_state.active) {
        return 0;  // æ²¡æœ‰ä¼ è¾“è¿›è¡Œä¸­
    }

    // æ£€æŸ¥ TD æ˜¯å¦å®Œæˆï¼ˆé€šè¿‡è¯»å– TD çŠ¶æ€ï¼‰
    // å†…å­˜å±éšœï¼šç¡®ä¿æˆ‘ä»¬çœ‹åˆ°æœ€æ–°çš„ TD çŠ¶æ€
    uint32_t ctrl_status = intr_state.td->ctrl_status;

    if (\!(ctrl_status & UHCI_TD_CTRL_ACT)) {
        // TD ä¸å†æ´»åŠ¨ - æ£€æŸ¥æ˜¯å¦æˆåŠŸå®Œæˆ
        uint32_t errors = (ctrl_status >> UHCI_TD_CTRL_ERR_SHIFT) & UHCI_TD_CTRL_ERR_MASK;

        if (errors == 0) {
            // æˆåŠŸï¼è®¡ç®—å®é™…ä¼ è¾“çš„å­—èŠ‚æ•°
            // å¯¹äº IN ä¼ è¾“ï¼Œå®é™…é•¿åº¦ = (MAXLEN + 1) - (act_len encoded)
            uint32_t token = intr_state.td->token;
            int max_len_encoded = (token >> UHCI_TD_TOKEN_MAXLEN_SHIFT) & 0x7FF;
            int actual_len = max_len_encoded + 1;

            intr_state.bytes_transferred = actual_len;
            intr_state.active = 0;

            printf("[USB] Interrupt complete: %d bytes\n", actual_len);
            return 1;
        } else {
            printf("[USB] ERROR: Transfer failed, status=0x%x\n", ctrl_status);
            intr_state.active = 0;
            return -1;
        }
    }

    // ä¼ è¾“ä»åœ¨è¿›è¡Œä¸­ - ç»§ç»­ç­‰å¾…
    return 0;  // ä»åœ¨ç­‰å¾…
}
