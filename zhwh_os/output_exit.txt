c[?7l[2J[0mSeaBIOS (version 1.16.3-debian-1.16.3-2)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1EFCAF60+1EF0AF60 CA00[05;76HPress Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from Hard Disk...
GRUB [01;01H[2J[02;30HGNU GRUB  version 2.12[04;02Hâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[04;43H[04;44Hâ”€[04;44H[04;45Hâ”€â”€â”€â”€â”€â”€[04;50H[04;51Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[04;70H[04;71Hâ”€â”€â”€â”€â”€â”€â”€â”€â”[05;02Hâ”‚[05;79Hâ”‚[06;02Hâ”‚[06;79Hâ”‚[07;02Hâ”‚[07;79Hâ”‚[08;02Hâ”‚[08;79Hâ”‚[09;02Hâ”‚[09;79Hâ”‚[10;02Hâ”‚[10;79Hâ”‚[11;02Hâ”‚[11;02H[11;79Hâ”‚[12;02Hâ”‚[12;79Hâ”‚[13;02Hâ”‚[13;79Hâ”‚[14;02Hâ”‚[14;79Hâ”‚[15;02Hâ”‚[15;79Hâ”‚[16;02Hâ”‚[16;02H[16;79Hâ”‚[17;02Hâ”‚[17;79Hâ”‚[18;02Hâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[18;14H[18;15Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[18;35H[18;36Hâ”€â”€â”€â”€[18;39H[18;40Hâ”€â”€â”€â”€â”€[18;44H[18;45Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[18;58H[18;59Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜[20;02H     Use the â†‘ and â†“[20;21H[20;22H keys to select which entry is [20;52H[20;53Hhighlighted.          
      Press enter to boot the selected OS, `e' [21;47H[21;48Hto edit the commands       
      before booting[22;20H[22;21H or `c' for a[22;33H[22;34H command-line.       [22;54H[22;55H                    [05;80H [05;03H [05;03H[05;04HMy OS - Direct Write Test                                                  [06;03H My OS - Simple printf Test           [06;40H[06;41H [06;41H[06;42H [06;42H[06;43H          [06;52H[06;53H                          [07;03H[0;30;47m*My OS - 5 Pro[07;16H[07;17Hcess Test                [07;41H[07;42H           [07;52H[07;53H                          [08;03H[0m [08;03H[08;04HMy OS - shell_demo Test                                          [08;68H[08;69H          [09;03H My OS - Simple Syscall Test                                                [10;03H                         [10;27H[10;28H                                                   [11;03H                                                                            [12;03H       [12;09H[12;10H                                   [12;44H[12;45H                     [12;65H[12;66H             [13;03H                                               [13;49H[13;50H                         [13;74H[13;75H    [14;03H              [14;16H[14;17H                                                              [15;03H                                                                            [16;03H    [16;06H[16;07H                                  [16;40H[16;41H                                      [17;03H                          [17;28H[17;29H                                                  [17;80H 





   The highlighted entry will be executed automatica[23;52H[23;53Hlly in 5s.                 [07;78H















   The highlig[23;14H[23;15Hhted entry will be executed automat[23;49H[23;50Hically in 4s.                 [07;78H















   The highlighted entry will b[23;31H[23;32He executed automaticall[23;54H[23;55Hy in 3s.                 [07;78H















 [23;02H  The highlighted entry will be executed automatically in 2s.  [23;64H[23;65H               [07;78H















 [23;02H  The highlighted entry will be executed automatically in 1s.                [23;78H[23;79H [07;78H















 [23;02H  The highlighted entry will be executed automatically in 0s.                 [01;01H[2J[2J[kernel_main] Saved kernel CR3 phys=0x101000
=== Serial initialized ===
Kernel Booted with Multiboot 2!
Magic: 0x36D76289
Info addr: 0x106010
cpuid is 0 
lapicid is 0 
 ---IOAPIC ---
ioapicid is 0 
ioapic addr is is 0xFEC00000 
Highmem mapping initialized
Identity mapped: 0xC0000000-0xC03FFFFF
Mapping buddy system metadata area (phys 16MB-48MB, 32MB total)...
Allocating new page table for directory entry 772
alloc_page_table: virt=0xC1000000, phys=0x1000000, pd_idx=772
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x200000, virt=0xC0200000
  Allocated PT at phys=0x200000
  Writing PDE: pd[772] = 0x200003
  pd[772] now = 0x200003
  pt_virt = 0xC0200000 (from pd[772]=0x200003)
  Clearing page table...
  Filling PTEs: phys=0x1000000 -> virt=0xC1000000
  Flushing TLB for virt=0xC1000000
  Done!
Allocated new page table for directory entry 0xC1000000
Allocated new page table for directory entry 0xC1000000
phys_addr is 0x1000000
virt_addr is 0xC1000000
pte is 0x0
  Mapped 0xC1000000 (phys 0x1000000)
  Mapped 0xC1100000 (phys 0x1100000)
  Mapped 0xC1200000 (phys 0x1200000)
  Mapped 0xC1300000 (phys 0x1300000)
Allocating new page table for directory entry 773
alloc_page_table: virt=0xC1400000, phys=0x1400000, pd_idx=773
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x201000, virt=0xC0201000
  Allocated PT at phys=0x201000
  Writing PDE: pd[773] = 0x201003
  pd[773] now = 0x201003
  pt_virt = 0xC0201000 (from pd[773]=0x201003)
  Clearing page table...
  Filling PTEs: phys=0x1400000 -> virt=0xC1400000
  Flushing TLB for virt=0xC1400000
  Done!
Allocated new page table for directory entry 0xC1400000
Allocated new page table for directory entry 0xC1400000
phys_addr is 0x1400000
virt_addr is 0xC1400000
pte is 0x0
  Mapped 0xC1400000 (phys 0x1400000)
  Mapped 0xC1500000 (phys 0x1500000)
  Mapped 0xC1600000 (phys 0x1600000)
  Mapped 0xC1700000 (phys 0x1700000)
Allocating new page table for directory entry 774
alloc_page_table: virt=0xC1800000, phys=0x1800000, pd_idx=774
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x202000, virt=0xC0202000
  Allocated PT at phys=0x202000
  Writing PDE: pd[774] = 0x202003
  pd[774] now = 0x202003
  pt_virt = 0xC0202000 (from pd[774]=0x202003)
  Clearing page table...
  Filling PTEs: phys=0x1800000 -> virt=0xC1800000
  Flushing TLB for virt=0xC1800000
  Done!
Allocated new page table for directory entry 0xC1800000
Allocated new page table for directory entry 0xC1800000
phys_addr is 0x1800000
virt_addr is 0xC1800000
pte is 0x0
  Mapped 0xC1800000 (phys 0x1800000)
  Mapped 0xC1900000 (phys 0x1900000)
  Mapped 0xC1A00000 (phys 0x1A00000)
  Mapped 0xC1B00000 (phys 0x1B00000)
Allocating new page table for directory entry 775
alloc_page_table: virt=0xC1C00000, phys=0x1C00000, pd_idx=775
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x203000, virt=0xC0203000
  Allocated PT at phys=0x203000
  Writing PDE: pd[775] = 0x203003
  pd[775] now = 0x203003
  pt_virt = 0xC0203000 (from pd[775]=0x203003)
  Clearing page table...
  Filling PTEs: phys=0x1C00000 -> virt=0xC1C00000
  Flushing TLB for virt=0xC1C00000
  Done!
Allocated new page table for directory entry 0xC1C00000
Allocated new page table for directory entry 0xC1C00000
phys_addr is 0x1C00000
virt_addr is 0xC1C00000
pte is 0x0
  Mapped 0xC1C00000 (phys 0x1C00000)
  Mapped 0xC1D00000 (phys 0x1D00000)
  Mapped 0xC1E00000 (phys 0x1E00000)
  Mapped 0xC1F00000 (phys 0x1F00000)
Allocating new page table for directory entry 776
alloc_page_table: virt=0xC2000000, phys=0x2000000, pd_idx=776
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x204000, virt=0xC0204000
  Allocated PT at phys=0x204000
  Writing PDE: pd[776] = 0x204003
  pd[776] now = 0x204003
  pt_virt = 0xC0204000 (from pd[776]=0x204003)
  Clearing page table...
  Filling PTEs: phys=0x2000000 -> virt=0xC2000000
  Flushing TLB for virt=0xC2000000
  Done!
Allocated new page table for directory entry 0xC2000000
Allocated new page table for directory entry 0xC2000000
phys_addr is 0x2000000
virt_addr is 0xC2000000
pte is 0x0
  Mapped 0xC2000000 (phys 0x2000000)
  Mapped 0xC2100000 (phys 0x2100000)
  Mapped 0xC2200000 (phys 0x2200000)
  Mapped 0xC2300000 (phys 0x2300000)
Allocating new page table for directory entry 777
alloc_page_table: virt=0xC2400000, phys=0x2400000, pd_idx=777
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x205000, virt=0xC0205000
  Allocated PT at phys=0x205000
  Writing PDE: pd[777] = 0x205003
  pd[777] now = 0x205003
  pt_virt = 0xC0205000 (from pd[777]=0x205003)
  Clearing page table...
  Filling PTEs: phys=0x2400000 -> virt=0xC2400000
  Flushing TLB for virt=0xC2400000
  Done!
Allocated new page table for directory entry 0xC2400000
Allocated new page table for directory entry 0xC2400000
phys_addr is 0x2400000
virt_addr is 0xC2400000
pte is 0x0
  Mapped 0xC2400000 (phys 0x2400000)
  Mapped 0xC2500000 (phys 0x2500000)
  Mapped 0xC2600000 (phys 0x2600000)
  Mapped 0xC2700000 (phys 0x2700000)
Allocating new page table for directory entry 778
alloc_page_table: virt=0xC2800000, phys=0x2800000, pd_idx=778
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x206000, virt=0xC0206000
  Allocated PT at phys=0x206000
  Writing PDE: pd[778] = 0x206003
  pd[778] now = 0x206003
  pt_virt = 0xC0206000 (from pd[778]=0x206003)
  Clearing page table...
  Filling PTEs: phys=0x2800000 -> virt=0xC2800000
  Flushing TLB for virt=0xC2800000
  Done!
Allocated new page table for directory entry 0xC2800000
Allocated new page table for directory entry 0xC2800000
phys_addr is 0x2800000
virt_addr is 0xC2800000
pte is 0x0
  Mapped 0xC2800000 (phys 0x2800000)
  Mapped 0xC2900000 (phys 0x2900000)
  Mapped 0xC2A00000 (phys 0x2A00000)
  Mapped 0xC2B00000 (phys 0x2B00000)
Allocating new page table for directory entry 779
alloc_page_table: virt=0xC2C00000, phys=0x2C00000, pd_idx=779
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x207000, virt=0xC0207000
  Allocated PT at phys=0x207000
  Writing PDE: pd[779] = 0x207003
  pd[779] now = 0x207003
  pt_virt = 0xC0207000 (from pd[779]=0x207003)
  Clearing page table...
  Filling PTEs: phys=0x2C00000 -> virt=0xC2C00000
  Flushing TLB for virt=0xC2C00000
  Done!
Allocated new page table for directory entry 0xC2C00000
Allocated new page table for directory entry 0xC2C00000
phys_addr is 0x2C00000
virt_addr is 0xC2C00000
pte is 0x0
  Mapped 0xC2C00000 (phys 0x2C00000)
  Mapped 0xC2D00000 (phys 0x2D00000)
  Mapped 0xC2E00000 (phys 0x2E00000)
  Mapped 0xC2F00000 (phys 0x2F00000)
Buddy system data area mapped successfully
Buddy System will use direct mapping (PHYS_TO_VIRT) instead of pre-mapping
Virtual address layout:
  User space:   0x00000000 - 0xBFFFFFFF (0-3GB)
  Kernel space: 0xC0000000 - 0xFFFFFFFF (3-4GB)
    Identity mapped: 0xC0000000 - 0xC07FFFFF (first 8MB)
    Direct mapping:  0xC0800000+ (computed as KERNEL_VIRT_BASE + phys)
Multiboot2 info: mem_lower=639 KB, mem_upper=523136 KB
Initializing memory management...
mm_init: starting memory management initialization
mm_init: detected 510 MB physical memory (mem_upper=523136 KB)
mm_init: initializing physical memory manager...
pmm_init: kernel_end_phys=0x3AE000
pmm_init: placing buddy system data at 16MB (0x1000000)
pmm_init: page tables will be created on-demand when accessing 0xC1000000+
pmm_init: buddy system data size: 20 MB at 0x1000000-0x2400000
pmm_init: buddy system data structures for 475 MB:
  max_blocks=121748, buddy_data_size=1 MB (1949696 bytes)
pmm_init: buddy_data_virt=0xC1000000 (will be mapped on-demand)
pmm_init: physical memory manager initialized
  start: 0x2400000 (36 MB), end: 0x1FF7FFFF (511 MB)
  total pages: 121728 (475 MB)
pmm_init: initializing buddy system...
  base_page=9216, managed_pages=121728, max_order=16
pmm_init: reserving 128 MB for kernel (pages 9216-41983)
buddy_init: base_page=9216, total_pages=121728, max_order=16
buddy_init: kernel_reserved_pages=32768 (128 MB)
buddy_init: using pre-allocated memory at 0xC1000000
buddy_init: max_blocks=121744, sizeof(buddy_block_t)=12
buddy_init: blocks_size=1460928, freelists_size=68, nextfree_size=486976
buddy_init: buddy_blocks_array=?
buddy_init: free_lists_array=?
buddy_init: next_free_array=?
buddy_init: skipping write test, proceeding to memset...
buddy_init: before memset free_lists
buddy_init: before memset next_free
buddy_init: after memset
buddy_init: creating initial free blocks
buddy_init: initialized 1 block (order 16 = 65536 pages)
buddy_init: SUCCESS - buddy system ready
pmm_init: buddy system enabled successfully
mm_init: basic memory detection complete (buddy system disabled)
mm_init: memory management initialization complete
Memory management initialized
After mm_init, before hardware init
---lapic_addr value is 0xFEE00000---
---lapic value is 0xFEE00000---
no Identity mapped---------
Allocating new page table for directory entry 770
alloc_page_table: virt=0xC0800000, phys=0xFEE00000, pd_idx=770
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x208000, virt=0xC0208000
  Allocated PT at phys=0x208000
  Writing PDE: pd[770] = 0x208003
  pd[770] now = 0x208003
  pt_virt = 0xC0208000 (from pd[770]=0x208003)
  Clearing page table...
  Filling PTEs: phys=0xFEE00000 -> virt=0xC0800000
  Flushing TLB for virt=0xC0800000
  Done!
Allocated new page table for directory entry 0xC0800000
Allocated new page table for directory entry 0xC0800000
phys_addr is 0xFEE00000
virt_addr is 0xC0800000
pte is 0x0
Mapped highmem: phys 0xFEE00000 -> virt 0xC0800000 (size: 4)
Before seginit
After seginit
Before tss_init
tss_init: starting
tss address: 0xC0109B50, sizeof(tss): 108
tss_init: before memset, will write 108 bytes
tss_init: after memset
TSS init: addr=0xC0109B50, ESP0=0xC03ADF88
TSS init:selector=0x28 
TSS loaded into task register
After tss_init
Before tvinit
[tvinit] System call gate (IDT[128]):
  offset=0xC010748F, seg=0x8, type=15, dpl=3, present=1
  vector128 address=0x?
After tvinit
segment idt init is ok
Global interrupts enabled
[KBD] Controller initialized, config=0x61
Keyboard driver initialized
PIC initial mask: 0xB8
PIC new mask: 0xB8 (verified)
Keyboard IRQ1 enabled via PIC (mask & 0x02 = 0)
Keyboard status port: 0x1C
VGA test: wrote TEST to screen at position 10-13

=== VBE/Framebuffer Detection (Multiboot2) ===
âœ“ Framebuffer info available!
  framebuffer_addr:   0x?lx
  framebuffer_pitch:  0
  framebuffer_width:  160
  framebuffer_height: 80
  framebuffer_bpp:    25
  framebuffer_type:   0
=============================================

task init
[init_task] kstack virt=0xC02A3160
[task_load] user task: cr3=NULL (will be set by task_prepare_pde)
start user task 
Tag 0: type=21, size=12
Tag 1: type=1, size=9
Tag 2: type=2, size=29
Tag 3: type=10, size=28
Tag 4: type=3, size=17
mod 0: start=0x3CB000 end=0x3CDA80 cmdline=
Tag 5: type=6, size=160
Tag 6: type=9, size=780
Tag 7: type=4, size=16
Tag 8: type=5, size=20
Tag 9: type=8, size=32
Tag 10: type=14, size=28
[user_task_main] START: th=0xC02A2160
User task started (task=0xC02A2160)
[user_task_main] Calling task_prepare_pde for th=0xC02A2160
[task_prepare_pde] START for task=0xC02A2160
[task_prepare_pde] User task using kernel CR3: 0x101000 (shared with all)
[task_prepare_pde] task->pde=0x101000 (kernel page directory)
[task_prepare_pde] Calling load_module_to_user...
[load_module_to_user] Starting...
[load_module_to_user] Module: start=0x3CB000 end=0x3CDA80 size=0x2A80 cmdline=
[load_module_to_user] Raw physical bytes at 0x3CB000: ?2x ?2x ?2x ?2x
[load_module_to_user] ELF header at virtual 0xC03CB000
[load_module_to_user] First 4 bytes: 0x7F 0x45 0x4C 0x46
[load_module_to_user] ELF file validated!
[load_module_to_user] e_entry=0x8000143, e_phoff=52, e_phnum=3
[load_module_to_user] Program Header 0: p_type=0x1
[load_module_to_user] PT_LOAD: va=0x8000000, file_pa=0x3CC000, memsz=0x820, filesz=0x820
[load_module_to_user] Starting page mapping loop...
[load_module_to_user] Loop: off=0, dst_va=0x8000000
[load_module_to_user] Copied 0x820 bytes from ELF to new page
[load_module_to_user] Calling map_page: dst_va=0x8000000 dst_pa=0x2401000
[map_page] vaddr=0x8000000 new PT at phys=0x2402000
[map_page] Set pd_user[32]=0x2402007
[map_page] Set pt[0]=0x2401007 (vaddr=0x8000000 -> paddr=0x2401000)
[load_module_to_user] Page mapping loop done.
[load_module_to_user] Program Header 1: p_type=0x4
[load_module_to_user] Program Header 2: p_type=0x6474E551
[load_module_to_user] Set tf->eip = 0x8000143 (from ELF entry)
[load_module_to_user] Set segment registers: CS=0x1B, DS/ES/FS/GS/SS=0x23
[load_module_to_user] Set tf->eflags = 0x200
[load_module_to_user] Mapping user stack (4 pages)...
[load_module_to_user] Allocated stack page 0: phys=0x2403000
[load_module_to_user] Mapping stack page: va=0xBFFFF000 -> pa=0x2403000
[map_page] vaddr=0xBFFFF000 new PT at phys=0x2404000
[map_page] Set pd_user[767]=0x2404007
[map_page] Set pt[1023]=0x2403007 (vaddr=0xBFFFF000 -> paddr=0x2403000)
[load_module_to_user] Allocated stack page 1: phys=0x2405000
[load_module_to_user] Mapping stack page: va=0xBFFFE000 -> pa=0x2405000
[map_page] vaddr=0xBFFFE000 reusing existing pd_user[767]=0x2404007
[map_page] Set pt[1022]=0x2405007 (vaddr=0xBFFFE000 -> paddr=0x2405000)
[load_module_to_user] Allocated stack page 2: phys=0x2406000
[load_module_to_user] Mapping stack page: va=0xBFFFD000 -> pa=0x2406000
[map_page] vaddr=0xBFFFD000 reusing existing pd_user[767]=0x2404007
[map_page] Set pt[1021]=0x2406007 (vaddr=0xBFFFD000 -> paddr=0x2406000)
[load_module_to_user] Allocated stack page 3: phys=0x2407000
[load_module_to_user] Mapping stack page: va=0xBFFFC000 -> pa=0x2407000
[map_page] vaddr=0xBFFFC000 reusing existing pd_user[767]=0x2404007
[map_page] Set pt[1020]=0x2407007 (vaddr=0xBFFFC000 -> paddr=0x2407000)
[load_module_to_user] User stack mapping complete.
[load_module_to_user] Set task->user_stack = 0x2403000 (physical address of stack top)
[load_module_to_user] Set up user stack ABI (Linux standard):
  argc=0 at [ESP]=0xBFFFEFFC
  argv[0]=NULL at [ESP+4]=0xBFFFF000
  Stack protected with 32 NULL dwords (128 bytes) below stack_top
[load_module_to_user] Trapframe setup:
  eip=0x8000143, esp=0xBFFFEFFC
  cs=0x1B, ss=0x23, ds=0x23, eflags=0x200
[task_prepare_pde] load_module_to_user returned, checking EIP...
[task_prepare_pde] task->tf=0xC02A3114, task->tf->eip=0x8000143
[task_prepare_pde] Verifying trapframe:
  eip=0x8000143, cs=0x1B, eflags=0x200, esp=0xBFFFEFFC
[task_prepare_pde] User stack already mapped by load_module_to_user (4 pages = 16KB)
[task_prepare_pde] User stack VA range: 0xBFFFB000 - 0xBFFFF000
[task_prepare_pde] Keeping tf->esp=0xBFFFEFFC (set by load_module_to_user)
[task_prepare_pde] This ESP points to argc, following Linux ABI standard
[user_task_main] Initialization complete, returning to scheduler
[start_task] DEBUG: pid=1, first_task=0xC02A2160, current_task[0]=0xC02A2160
[start_task] Added task pid=1 to chain: prev->pid=1, next->pid=1
[kernel_main] User task initialized, state=PS_CREATED
user task 0xC02A2160 kernel task 0x0
Starting scheduler with multiple tasks...
[schedule] ENTRY - schedule() called!
[schedule] Initialized schedule_switch_to_return_addr=0xC011279D
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=1, state=64, user_stack=0x2403000
[pick_next_task_cfs] current->next=0xC02A2160
[pick_next_task_cfs] no other task, keeping current: pid=1
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2403000, state=64)
[schedule] First time entering user mode for pid=1
[schedule] About to call task_to_user_mode_with_task, next=0xC02A2160
[task_to_user_mode_wrapper] ENTRY: task=0xC02A2160
[task_to_user_mode_wrapper] task=0xC02A2160, pid=1
[task_to_user_mode_wrapper] task->tf=0xC02A3114
[task_to_user_mode_wrapper] trapframe content:
  eip=0x8000143, cs=0x1B, eflags=0x200
  esp=0xBFFFEFFC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC02A2160 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC02A2160
[syscall] SYS_PUTCHAR: char=0x53 ('S')
S[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x74 ('t')
t[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x61 ('a')
a[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x72 ('r')
r[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x74 ('t')
t[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0xA ('
')

[syscall] SYS_PUTCHAR: done, eax=0
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A2160, parent->tf=0xC02A3114, parent->kstack=0xC02A3160
[do_fork] Temporarily switched CR3: 0x101000 -> 0x101003
[do_fork] Mapping child task struct to kernel page table: phys=0x2408000, virt=0xC2408000
[map_page] vaddr=0xC2408000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[8]=0x2408003 (vaddr=0xC2408000 -> paddr=0x2408000)
[do_fork] Child task struct mapped
[do_fork] Child task struct virt=0xC2408000, kstack_phys=0x2409000, kstack_virt=0xC2409000, esp=0xC240A000
[do_fork] Mapping child kstack to kernel page table: phys=0x2409000, virt=0xC2409000
[map_page] vaddr=0xC2409000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[9]=0x2409003 (vaddr=0xC2409000 -> paddr=0x2409000)
[do_fork] Child kernel stack mapped to kernel page table
[do_fork] Creating independent page directory for child...
[do_fork] Allocated child PD: phys=0x240A000, virt=0xC240A000
[do_fork] Copied kernel mappings (768-1023)
[do_fork] memcpy: parent_pt_virt=0xC2402000, child_pt_virt=0xC240B000
[do_fork] Copied PD[32]: parent_pt=0x2402000 -> child_pt=0x240B000
[do_fork] memcpy: parent_pt_virt=0xC2404000, child_pt_virt=0xC240C000
[do_fork] Copied PD[767]: parent_pt=0x2404000 -> child_pt=0x240C000
[do_fork] Copied user space page tables (0-767)
[do_fork] Child using independent CR3: 0x240A000
[do_fork] DEBUG: child task struct addr=0xC2408000
[do_fork] DEBUG: &child->tf=0xC2408098, offset=152
[do_fork] DEBUG: child->tf=0xC2409FB4 (value stored)
[do_fork] Before memcpy: child->tf=0xC2409FB4, parent->tf=0xC02A3114, size=76
[do_fork] Trapframe copied successfully
[do_fork] Trapframe copied: eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Parent tf at 0xC02A3114, Child tf at 0xC2409FB4, sizeof(tf)=76
[do_fork] Child trapfield DUMP:
  eip=0x80002A3, cs=0x1B, eflags=0x282
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0, ebx=0xA, ecx=0x0, edx=0x0
  esi=0x0, edi=0x0, ebp=0xBFFFEFF8
[do_fork] Child sharing parent's address space (including user stack)
[do_fork] âš ï¸ WARNING: Multiple children will overwrite each other's user stack!
[do_fork] âš ï¸ TODO: Implement COW (Copy-On-Write) mechanism
[do_fork] Child trapframe ready: tf=0xC2409FB4, eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Child will enter user mode via task_to_user_mode_with_task
[do_fork] Found first_task: pid=1
[do_fork] Added child to circular list: prev->pid=1, next->pid=1
[do_fork] Child PID=2 created successfully, state=64 (PS_CREATED)
[do_fork] Restored CR3: 0x101003 -> 0x101000
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A2160, parent->tf=0xC02A3114, parent->kstack=0xC02A3160
[do_fork] Temporarily switched CR3: 0x101000 -> 0x101003
[do_fork] Mapping child task struct to kernel page table: phys=0x240D000, virt=0xC240D000
[map_page] vaddr=0xC240D000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[13]=0x240D003 (vaddr=0xC240D000 -> paddr=0x240D000)
[do_fork] Child task struct mapped
[do_fork] Child task struct virt=0xC240D000, kstack_phys=0x240E000, kstack_virt=0xC240E000, esp=0xC240F000
[do_fork] Mapping child kstack to kernel page table: phys=0x240E000, virt=0xC240E000
[map_page] vaddr=0xC240E000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[14]=0x240E003 (vaddr=0xC240E000 -> paddr=0x240E000)
[do_fork] Child kernel stack mapped to kernel page table
[do_fork] Creating independent page directory for child...
[do_fork] Allocated child PD: phys=0x240F000, virt=0xC240F000
[do_fork] Copied kernel mappings (768-1023)
[do_fork] memcpy: parent_pt_virt=0xC2402000, child_pt_virt=0xC2410000
[do_fork] Copied PD[32]: parent_pt=0x2402000 -> child_pt=0x2410000
[do_fork] memcpy: parent_pt_virt=0xC2404000, child_pt_virt=0xC2411000
[do_fork] Copied PD[767]: parent_pt=0x2404000 -> child_pt=0x2411000
[do_fork] Copied user space page tables (0-767)
[do_fork] Child using independent CR3: 0x240F000
[do_fork] DEBUG: child task struct addr=0xC240D000
[do_fork] DEBUG: &child->tf=0xC240D098, offset=152
[do_fork] DEBUG: child->tf=0xC240EFB4 (value stored)
[do_fork] Before memcpy: child->tf=0xC240EFB4, parent->tf=0xC02A3114, size=76
[do_fork] Trapframe copied successfully
[do_fork] Trapframe copied: eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Parent tf at 0xC02A3114, Child tf at 0xC240EFB4, sizeof(tf)=76
[do_fork] Child trapfield DUMP:
  eip=0x80002A3, cs=0x1B, eflags=0x202
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0, ebx=0xA, ecx=0x0, edx=0x0
  esi=0x0, edi=0x0, ebp=0xBFFFEFF8
[do_fork] Child sharing parent's address space (including user stack)
[do_fork] âš ï¸ WARNING: Multiple children will overwrite each other's user stack!
[do_fork] âš ï¸ TODO: Implement COW (Copy-On-Write) mechanism
[do_fork] Child trapframe ready: tf=0xC240EFB4, eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Child will enter user mode via task_to_user_mode_with_task
[do_fork] Found first_task: pid=1
[do_fork] Added child to circular list: prev->pid=2, next->pid=1
[do_fork] Child PID=3 created successfully, state=64 (PS_CREATED)
[do_fork] Restored CR3: 0x101003 -> 0x101000
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A2160, parent->tf=0xC02A3114, parent->kstack=0xC02A3160
[do_fork] Temporarily switched CR3: 0x101000 -> 0x101003
[do_fork] Mapping child task struct to kernel page table: phys=0x2412000, virt=0xC2412000
[map_page] vaddr=0xC2412000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[18]=0x2412003 (vaddr=0xC2412000 -> paddr=0x2412000)
[do_fork] Child task struct mapped
[do_fork] Child task struct virt=0xC2412000, kstack_phys=0x2413000, kstack_virt=0xC2413000, esp=0xC2414000
[do_fork] Mapping child kstack to kernel page table: phys=0x2413000, virt=0xC2413000
[map_page] vaddr=0xC2413000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[19]=0x2413003 (vaddr=0xC2413000 -> paddr=0x2413000)
[do_fork] Child kernel stack mapped to kernel page table
[do_fork] Creating independent page directory for child...
[do_fork] Allocated child PD: phys=0x2414000, virt=0xC2414000
[do_fork] Copied kernel mappings (768-1023)
[do_fork] memcpy: parent_pt_virt=0xC2402000, child_pt_virt=0xC2415000
[do_fork] Copied PD[32]: parent_pt=0x2402000 -> child_pt=0x2415000
[do_fork] memcpy: parent_pt_virt=0xC2404000, child_pt_virt=0xC2416000
[do_fork] Copied PD[767]: parent_pt=0x2404000 -> child_pt=0x2416000
[do_fork] Copied user space page tables (0-767)
[do_fork] Child using independent CR3: 0x2414000
[do_fork] DEBUG: child task struct addr=0xC2412000
[do_fork] DEBUG: &child->tf=0xC2412098, offset=152
[do_fork] DEBUG: child->tf=0xC2413FB4 (value stored)
[do_fork] Before memcpy: child->tf=0xC2413FB4, parent->tf=0xC02A3114, size=76
[do_fork] Trapframe copied successfully
[do_fork] Trapframe copied: eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Parent tf at 0xC02A3114, Child tf at 0xC2413FB4, sizeof(tf)=76
[do_fork] Child trapfield DUMP:
  eip=0x80002A3, cs=0x1B, eflags=0x206
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0, ebx=0xA, ecx=0x0, edx=0x0
  esi=0x0, edi=0x0, ebp=0xBFFFEFF8
[do_fork] Child sharing parent's address space (including user stack)
[do_fork] âš ï¸ WARNING: Multiple children will overwrite each other's user stack!
[do_fork] âš ï¸ TODO: Implement COW (Copy-On-Write) mechanism
[do_fork] Child trapframe ready: tf=0xC2413FB4, eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Child will enter user mode via task_to_user_mode_with_task
[do_fork] Found first_task: pid=1
[do_fork] Added child to circular list: prev->pid=3, next->pid=1
[do_fork] Child PID=4 created successfully, state=64 (PS_CREATED)
[do_fork] Restored CR3: 0x101003 -> 0x101000
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A2160, parent->tf=0xC02A3114, parent->kstack=0xC02A3160
[do_fork] Temporarily switched CR3: 0x101000 -> 0x101003
[do_fork] Mapping child task struct to kernel page table: phys=0x2417000, virt=0xC2417000
[map_page] vaddr=0xC2417000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[23]=0x2417003 (vaddr=0xC2417000 -> paddr=0x2417000)
[do_fork] Child task struct mapped
[do_fork] Child task struct virt=0xC2417000, kstack_phys=0x2418000, kstack_virt=0xC2418000, esp=0xC2419000
[do_fork] Mapping child kstack to kernel page table: phys=0x2418000, virt=0xC2418000
[map_page] vaddr=0xC2418000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[24]=0x2418003 (vaddr=0xC2418000 -> paddr=0x2418000)
[do_fork] Child kernel stack mapped to kernel page table
[do_fork] Creating independent page directory for child...
[do_fork] Allocated child PD: phys=0x2419000, virt=0xC2419000
[do_fork] Copied kernel mappings (768-1023)
[do_fork] memcpy: parent_pt_virt=0xC2402000, child_pt_virt=0xC241A000
[do_fork] Copied PD[32]: parent_pt=0x2402000 -> child_pt=0x241A000
[do_fork] memcpy: parent_pt_virt=0xC2404000, child_pt_virt=0xC241B000
[do_fork] Copied PD[767]: parent_pt=0x2404000 -> child_pt=0x241B000
[do_fork] Copied user space page tables (0-767)
[do_fork] Child using independent CR3: 0x2419000
[do_fork] DEBUG: child task struct addr=0xC2417000
[do_fork] DEBUG: &child->tf=0xC2417098, offset=152
[do_fork] DEBUG: child->tf=0xC2418FB4 (value stored)
[do_fork] Before memcpy: child->tf=0xC2418FB4, parent->tf=0xC02A3114, size=76
[do_fork] Trapframe copied successfully
[do_fork] Trapframe copied: eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Parent tf at 0xC02A3114, Child tf at 0xC2418FB4, sizeof(tf)=76
[do_fork] Child trapfield DUMP:
  eip=0x80002A3, cs=0x1B, eflags=0x202
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0, ebx=0xA, ecx=0x0, edx=0x0
  esi=0x0, edi=0x0, ebp=0xBFFFEFF8
[do_fork] Child sharing parent's address space (including user stack)
[do_fork] âš ï¸ WARNING: Multiple children will overwrite each other's user stack!
[do_fork] âš ï¸ TODO: Implement COW (Copy-On-Write) mechanism
[do_fork] Child trapframe ready: tf=0xC2418FB4, eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Child will enter user mode via task_to_user_mode_with_task
[do_fork] Found first_task: pid=1
[do_fork] Added child to circular list: prev->pid=4, next->pid=1
[do_fork] Child PID=5 created successfully, state=64 (PS_CREATED)
[do_fork] Restored CR3: 0x101003 -> 0x101000
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x40 ('@')
@[syscall] SYS_PUTCHAR: done, eax=0
[PF] fault_addr=0x0 err=0x5 eip=0x0
[PF] User task page fault, terminating
[do_exit] Task 1 exiting with code -1
[do_exit] Freeing user stack at 0x2403000 (virt)
[do_exit] Trapframe was at 0xC02A3114 (will be freed with kstack)
[do_exit] Kernel stack at 0xC02A3160 (keeping for now)
[do_exit] Task 1 marked as terminated
[schedule] ENTRY - schedule() called!
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x82
[pick_next_task_cfs] current: pid=1, state=2, user_stack=0x0
[pick_next_task_cfs] current->next=0xC2408000
[pick_next_task_cfs] [0] checking next: pid=2, state=64, user_stack=0x2403000, can_schedule=1
[pick_next_task_cfs] selected next: pid=2
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2403000, state=64)
[schedule] First time entering user mode for pid=2
[schedule] About to call task_to_user_mode_with_task, next=0xC2408000
[task_to_user_mode_wrapper] ENTRY: task=0xC2408000
[task_to_user_mode_wrapper] task=0xC2408000, pid=2
[task_to_user_mode_wrapper] task->tf=0xC2409FB4
[task_to_user_mode_wrapper] trapframe content:
  eip=0x80002A3, cs=0x1B, eflags=0x282
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC2408000 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC2408000
[syscall] SYS_PUTCHAR: char=0x50 ('P')
P[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x34 ('4')
4[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x2D ('-')
-[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x30 ('0')
0[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x20 (' ')
 [syscall] SYS_PUTCHAR: done, eax=0
[schedule] ENTRY - schedule() called!
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=2, state=1, user_stack=0x2403000
[pick_next_task_cfs] current->next=0xC240D000
[pick_next_task_cfs] [0] checking next: pid=3, state=64, user_stack=0x2403000, can_schedule=1
[pick_next_task_cfs] selected next: pid=3
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2403000, state=64)
[schedule] First time entering user mode for pid=3
[schedule] About to call task_to_user_mode_with_task, next=0xC240D000
[task_to_user_mode_wrapper] ENTRY: task=0xC240D000
[task_to_user_mode_wrapper] task=0xC240D000, pid=3
[task_to_user_mode_wrapper] task->tf=0xC240EFB4
[task_to_user_mode_wrapper] trapframe content:
  eip=0x80002A3, cs=0x1B, eflags=0x202
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC240D000 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC240D000
[syscall] SYS_PUTCHAR: char=0x50 ('P')
P[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x34 ('4')
4[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x2D ('-')
-[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x30 ('0')
0[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x20 (' ')
 [syscall] SYS_PUTCHAR: done, eax=0
[schedule] ENTRY - schedule() called!
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=3, state=1, user_stack=0x2403000
[pick_next_task_cfs] current->next=0xC2412000
[pick_next_task_cfs] [0] checking next: pid=4, state=64, user_stack=0x2403000, can_schedule=1
[pick_next_task_cfs] selected next: pid=4
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2403000, state=64)
[schedule] First time entering user mode for pid=4
[schedule] About to call task_to_user_mode_with_task, next=0xC2412000
[task_to_user_mode_wrapper] ENTRY: task=0xC2412000
[task_to_user_mode_wrapper] task=0xC2412000, pid=4
[task_to_user_mode_wrapper] task->tf=0xC2413FB4
[task_to_user_mode_wrapper] trapframe content:
  eip=0x80002A3, cs=0x1B, eflags=0x206
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC2412000 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC2412000
[syscall] SYS_PUTCHAR: char=0x50 ('P')
P[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x34 ('4')
4[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x2D ('-')
-[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x30 ('0')
0[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x20 (' ')
 [syscall] SYS_PUTCHAR: done, eax=0
[schedule] ENTRY - schedule() called!
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=4, state=1, user_stack=0x2403000
[pick_next_task_cfs] current->next=0xC2417000
[pick_next_task_cfs] [0] checking next: pid=5, state=64, user_stack=0x2403000, can_schedule=1
[pick_next_task_cfs] selected next: pid=5
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2403000, state=64)
[schedule] First time entering user mode for pid=5
[schedule] About to call task_to_user_mode_with_task, next=0xC2417000
[task_to_user_mode_wrapper] ENTRY: task=0xC2417000
[task_to_user_mode_wrapper] task=0xC2417000, pid=5
[task_to_user_mode_wrapper] task->tf=0xC2418FB4
[task_to_user_mode_wrapper] trapframe content:
  eip=0x80002A3, cs=0x1B, eflags=0x202
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC2417000 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC2417000
[syscall] SYS_PUTCHAR: char=0x50 ('P')
P[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x34 ('4')
4[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x2D ('-')
-[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x30 ('0')
0[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x20 (' ')
 [syscall] SYS_PUTCHAR: done, eax=0
[schedule] ENTRY - schedule() called!
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=5, state=1, user_stack=0x2403000
[pick_next_task_cfs] current->next=0xC02A2160
[pick_next_task_cfs] [0] checking next: pid=1, state=2, user_stack=0x0, can_schedule=0
[pick_next_task_cfs] skipping kernel task pid=1 (no user_stack)
[pick_next_task_cfs] [1] checking next: pid=2, state=0, user_stack=0x2403000, can_schedule=1
[pick_next_task_cfs] selected next: pid=2
[schedule] first_time_user=0, switch_to_user=0 (user_stack=0x2403000, state=0)
[schedule] CPU0: switch from task_5 to task_2
c[?7l[2J[0mSeaBIOS (version 1.16.3-debian-1.16.3-2)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1EFCAF60+1EF0AF60 CA00
Press Ctrl-B to configure iPXE (PCI 00:03.0)...                                                                               


Booting from Hard Disk...
GRUB [01;01H[2J[02;30HGNU GRUB  version 2.12[04;02Hâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€[04;11H[04;12Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[04;32H[04;33Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[04;55H[04;56Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[04;77H[04;78Hâ”€â”[05;02Hâ”‚[05;79Hâ”‚[06;02Hâ”‚[06;79Hâ”‚[07;02Hâ”‚[07;79Hâ”‚[08;02Hâ”‚[08;79Hâ”‚[09;02Hâ”‚[09;79Hâ”‚[10;02Hâ”‚[10;79Hâ”‚[11;02Hâ”‚[11;79Hâ”‚[12;02Hâ”‚[12;79Hâ”‚[13;02Hâ”‚[13;79Hâ”‚[14;02Hâ”‚[14;02H[14;79Hâ”‚[15;02Hâ”‚[15;79Hâ”‚[16;02Hâ”‚[16;79Hâ”‚[17;02Hâ”‚[17;79Hâ”‚[18;02Hâ””â”€â”€â”€[18;05H[18;06Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[18;54H[18;55Hâ”€â”€â”€â”€â”€â”€[18;60H[18;61Hâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜[20;02H     Use the â†‘ and â†“ keys to select which entry is highlighted.          
      Press enter to boot the select[21;36H[21;37Hed OS, `e' to edit the commands  [21;69H[21;70H     
      before booting or `c'[22;27H[22;28H for a command-line.                           [05;80H [05;03H My OS - Direct Write Test                          [05;54H[05;55H                        [06;03H My O[06;07H[06;08HS - Simple printf Test                                           [06;72H[06;73H      [07;03H[0;30;47m*My OS - 5 Process Test                                                     [08;03H[0m M[08;04H[08;05Hy OS - shell_demo Test        [08;34H[08;35H                                        [08;74H[08;75H    [09;03H My OS - Simple[09;17H[09;18H Syscall Test  [09;32H[09;33H                                              [09;78H[10;03H                               [10;33H[10;34H                                   [10;68H[10;69H          [11;03H           [11;13H[11;14H                          [11;39H[11;40H                                       [12;03H                      [12;24H[12;25H                                 [12;57H[12;58H                     [13;03H         [13;11H[13;12H                                                                   [14;03H [14;03H[14;04H                              [14;33H[14;34H                              [14;63H[14;64H               [15;03H                                               [15;49H[15;50H                             [16;03H [16;03H[16;04H                                [16;35H[16;36H                                           [17;03H [17;03H[17;04H                [17;19H[17;20H                                [17;51H[17;52H                      [17;73H[17;74H     [17;80H 





   The highlighted entry w[23;26H[23;27Hill be executed automatically in 5s.                 [07;78H















   The highlighted entry will be executed automatically in 4s.                 [07;78H















 [23;02H  The highlighted entry will be executed automatically in 3s.      [23;68H[23;69H           [07;78H















   The highlighted[23;18H[23;19H entry will be executed automatical[23;53H[23;54Hly in 2s.                 [07;78H















   The highlighted entry will be executed automatically in 1s.           [23;73H[23;74H      [07;78H















   [23;03H[23;04HThe highlighted entry will be executed automatically in 0s.    [23;66H[23;67H             [01;01H[2J[2J[kernel_main] Saved kernel CR3 phys=0x101000
=== Serial initialized ===
Kernel Booted with Multiboot 2!
Magic: 0x36D76289
Info addr: 0x106010
cpuid is 0 
lapicid is 0 
 ---IOAPIC ---
ioapicid is 0 
ioapic addr is is 0xFEC00000 
Highmem mapping initialized
Identity mapped: 0xC0000000-0xC03FFFFF
Mapping buddy system metadata area (phys 16MB-48MB, 32MB total)...
Allocating new page table for directory entry 772
alloc_page_table: virt=0xC1000000, phys=0x1000000, pd_idx=772
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x200000, virt=0xC0200000
  Allocated PT at phys=0x200000
  Writing PDE: pd[772] = 0x200003
  pd[772] now = 0x200003
  pt_virt = 0xC0200000 (from pd[772]=0x200003)
  Clearing page table...
  Filling PTEs: phys=0x1000000 -> virt=0xC1000000
  Flushing TLB for virt=0xC1000000
  Done!
Allocated new page table for directory entry 0xC1000000
Allocated new page table for directory entry 0xC1000000
phys_addr is 0x1000000
virt_addr is 0xC1000000
pte is 0x110
  Mapped 0xC1000000 (phys 0x1000000)
  Mapped 0xC1100000 (phys 0x1100000)
  Mapped 0xC1200000 (phys 0x1200000)
  Mapped 0xC1300000 (phys 0x1300000)
Allocating new page table for directory entry 773
alloc_page_table: virt=0xC1400000, phys=0x1400000, pd_idx=773
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x201000, virt=0xC0201000
  Allocated PT at phys=0x201000
  Writing PDE: pd[773] = 0x201003
  pd[773] now = 0x201003
  pt_virt = 0xC0201000 (from pd[773]=0x201003)
  Clearing page table...
  Filling PTEs: phys=0x1400000 -> virt=0xC1400000
  Flushing TLB for virt=0xC1400000
  Done!
Allocated new page table for directory entry 0xC1400000
Allocated new page table for directory entry 0xC1400000
phys_addr is 0x1400000
virt_addr is 0xC1400000
pte is 0x0
  Mapped 0xC1400000 (phys 0x1400000)
  Mapped 0xC1500000 (phys 0x1500000)
  Mapped 0xC1600000 (phys 0x1600000)
  Mapped 0xC1700000 (phys 0x1700000)
Allocating new page table for directory entry 774
alloc_page_table: virt=0xC1800000, phys=0x1800000, pd_idx=774
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x202000, virt=0xC0202000
  Allocated PT at phys=0x202000
  Writing PDE: pd[774] = 0x202003
  pd[774] now = 0x202003
  pt_virt = 0xC0202000 (from pd[774]=0x202003)
  Clearing page table...
  Filling PTEs: phys=0x1800000 -> virt=0xC1800000
  Flushing TLB for virt=0xC1800000
  Done!
Allocated new page table for directory entry 0xC1800000
Allocated new page table for directory entry 0xC1800000
phys_addr is 0x1800000
virt_addr is 0xC1800000
pte is 0x0
  Mapped 0xC1800000 (phys 0x1800000)
  Mapped 0xC1900000 (phys 0x1900000)
  Mapped 0xC1A00000 (phys 0x1A00000)
  Mapped 0xC1B00000 (phys 0x1B00000)
Allocating new page table for directory entry 775
alloc_page_table: virt=0xC1C00000, phys=0x1C00000, pd_idx=775
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x203000, virt=0xC0203000
  Allocated PT at phys=0x203000
  Writing PDE: pd[775] = 0x203003
  pd[775] now = 0x203003
  pt_virt = 0xC0203000 (from pd[775]=0x203003)
  Clearing page table...
  Filling PTEs: phys=0x1C00000 -> virt=0xC1C00000
  Flushing TLB for virt=0xC1C00000
  Done!
Allocated new page table for directory entry 0xC1C00000
Allocated new page table for directory entry 0xC1C00000
phys_addr is 0x1C00000
virt_addr is 0xC1C00000
pte is 0x0
  Mapped 0xC1C00000 (phys 0x1C00000)
  Mapped 0xC1D00000 (phys 0x1D00000)
  Mapped 0xC1E00000 (phys 0x1E00000)
  Mapped 0xC1F00000 (phys 0x1F00000)
Allocating new page table for directory entry 776
alloc_page_table: virt=0xC2000000, phys=0x2000000, pd_idx=776
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x204000, virt=0xC0204000
  Allocated PT at phys=0x204000
  Writing PDE: pd[776] = 0x204003
  pd[776] now = 0x204003
  pt_virt = 0xC0204000 (from pd[776]=0x204003)
  Clearing page table...
  Filling PTEs: phys=0x2000000 -> virt=0xC2000000
  Flushing TLB for virt=0xC2000000
  Done!
Allocated new page table for directory entry 0xC2000000
Allocated new page table for directory entry 0xC2000000
phys_addr is 0x2000000
virt_addr is 0xC2000000
pte is 0x0
  Mapped 0xC2000000 (phys 0x2000000)
  Mapped 0xC2100000 (phys 0x2100000)
  Mapped 0xC2200000 (phys 0x2200000)
  Mapped 0xC2300000 (phys 0x2300000)
Allocating new page table for directory entry 777
alloc_page_table: virt=0xC2400000, phys=0x2400000, pd_idx=777
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x205000, virt=0xC0205000
  Allocated PT at phys=0x205000
  Writing PDE: pd[777] = 0x205003
  pd[777] now = 0x205003
  pt_virt = 0xC0205000 (from pd[777]=0x205003)
  Clearing page table...
  Filling PTEs: phys=0x2400000 -> virt=0xC2400000
  Flushing TLB for virt=0xC2400000
  Done!
Allocated new page table for directory entry 0xC2400000
Allocated new page table for directory entry 0xC2400000
phys_addr is 0x2400000
virt_addr is 0xC2400000
pte is 0x0
  Mapped 0xC2400000 (phys 0x2400000)
  Mapped 0xC2500000 (phys 0x2500000)
  Mapped 0xC2600000 (phys 0x2600000)
  Mapped 0xC2700000 (phys 0x2700000)
Allocating new page table for directory entry 778
alloc_page_table: virt=0xC2800000, phys=0x2800000, pd_idx=778
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x206000, virt=0xC0206000
  Allocated PT at phys=0x206000
  Writing PDE: pd[778] = 0x206003
  pd[778] now = 0x206003
  pt_virt = 0xC0206000 (from pd[778]=0x206003)
  Clearing page table...
  Filling PTEs: phys=0x2800000 -> virt=0xC2800000
  Flushing TLB for virt=0xC2800000
  Done!
Allocated new page table for directory entry 0xC2800000
Allocated new page table for directory entry 0xC2800000
phys_addr is 0x2800000
virt_addr is 0xC2800000
pte is 0x0
  Mapped 0xC2800000 (phys 0x2800000)
  Mapped 0xC2900000 (phys 0x2900000)
  Mapped 0xC2A00000 (phys 0x2A00000)
  Mapped 0xC2B00000 (phys 0x2B00000)
Allocating new page table for directory entry 779
alloc_page_table: virt=0xC2C00000, phys=0x2C00000, pd_idx=779
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x207000, virt=0xC0207000
  Allocated PT at phys=0x207000
  Writing PDE: pd[779] = 0x207003
  pd[779] now = 0x207003
  pt_virt = 0xC0207000 (from pd[779]=0x207003)
  Clearing page table...
  Filling PTEs: phys=0x2C00000 -> virt=0xC2C00000
  Flushing TLB for virt=0xC2C00000
  Done!
Allocated new page table for directory entry 0xC2C00000
Allocated new page table for directory entry 0xC2C00000
phys_addr is 0x2C00000
virt_addr is 0xC2C00000
pte is 0x0
  Mapped 0xC2C00000 (phys 0x2C00000)
  Mapped 0xC2D00000 (phys 0x2D00000)
  Mapped 0xC2E00000 (phys 0x2E00000)
  Mapped 0xC2F00000 (phys 0x2F00000)
Buddy system data area mapped successfully
Buddy System will use direct mapping (PHYS_TO_VIRT) instead of pre-mapping
Virtual address layout:
  User space:   0x00000000 - 0xBFFFFFFF (0-3GB)
  Kernel space: 0xC0000000 - 0xFFFFFFFF (3-4GB)
    Identity mapped: 0xC0000000 - 0xC07FFFFF (first 8MB)
    Direct mapping:  0xC0800000+ (computed as KERNEL_VIRT_BASE + phys)
Multiboot2 info: mem_lower=639 KB, mem_upper=523136 KB
Initializing memory management...
mm_init: starting memory management initialization
mm_init: detected 510 MB physical memory (mem_upper=523136 KB)
mm_init: initializing physical memory manager...
pmm_init: kernel_end_phys=0x3AE000
pmm_init: placing buddy system data at 16MB (0x1000000)
pmm_init: page tables will be created on-demand when accessing 0xC1000000+
pmm_init: buddy system data size: 20 MB at 0x1000000-0x2400000
pmm_init: buddy system data structures for 475 MB:
  max_blocks=121748, buddy_data_size=1 MB (1949696 bytes)
pmm_init: buddy_data_virt=0xC1000000 (will be mapped on-demand)
pmm_init: physical memory manager initialized
  start: 0x2400000 (36 MB), end: 0x1FF7FFFF (511 MB)
  total pages: 121728 (475 MB)
pmm_init: initializing buddy system...
  base_page=9216, managed_pages=121728, max_order=16
pmm_init: reserving 128 MB for kernel (pages 9216-41983)
buddy_init: base_page=9216, total_pages=121728, max_order=16
buddy_init: kernel_reserved_pages=32768 (128 MB)
buddy_init: using pre-allocated memory at 0xC1000000
buddy_init: max_blocks=121744, sizeof(buddy_block_t)=12
buddy_init: blocks_size=1460928, freelists_size=68, nextfree_size=486976
buddy_init: buddy_blocks_array=?
buddy_init: free_lists_array=?
buddy_init: next_free_array=?
buddy_init: skipping write test, proceeding to memset...
buddy_init: before memset free_lists
buddy_init: before memset next_free
buddy_init: after memset
buddy_init: creating initial free blocks
buddy_init: initialized 1 block (order 16 = 65536 pages)
buddy_init: SUCCESS - buddy system ready
pmm_init: buddy system enabled successfully
mm_init: basic memory detection complete (buddy system disabled)
mm_init: memory management initialization complete
Memory management initialized
After mm_init, before hardware init
---lapic_addr value is 0xFEE00000---
---lapic value is 0xFEE00000---
no Identity mapped---------
Allocating new page table for directory entry 770
alloc_page_table: virt=0xC0800000, phys=0xFEE00000, pd_idx=770
  pd[pd_idx]=0x0
  Page table not present, allocating...
alloc_early_page_table: allocated phys=0x208000, virt=0xC0208000
  Allocated PT at phys=0x208000
  Writing PDE: pd[770] = 0x208003
  pd[770] now = 0x208003
  pt_virt = 0xC0208000 (from pd[770]=0x208003)
  Clearing page table...
  Filling PTEs: phys=0xFEE00000 -> virt=0xC0800000
  Flushing TLB for virt=0xC0800000
  Done!
Allocated new page table for directory entry 0xC0800000
Allocated new page table for directory entry 0xC0800000
phys_addr is 0xFEE00000
virt_addr is 0xC0800000
pte is 0x0
Mapped highmem: phys 0xFEE00000 -> virt 0xC0800000 (size: 4)
Before seginit
After seginit
Before tss_init
tss_init: starting
tss address: 0xC0109B50, sizeof(tss): 108
tss_init: before memset, will write 108 bytes
tss_init: after memset
TSS init: addr=0xC0109B50, ESP0=0xC03ADF88
TSS init:selector=0x28 
TSS loaded into task register
After tss_init
Before tvinit
[tvinit] System call gate (IDT[128]):
  offset=0xC010748F, seg=0x8, type=15, dpl=3, present=1
  vector128 address=0x?
After tvinit
segment idt init is ok
Global interrupts enabled
[KBD] Controller initialized, config=0x61
Keyboard driver initialized
PIC initial mask: 0xB8
PIC new mask: 0xB8 (verified)
Keyboard IRQ1 enabled via PIC (mask & 0x02 = 0)
Keyboard status port: 0x1C
VGA test: wrote TEST to screen at position 10-13

=== VBE/Framebuffer Detection (Multiboot2) ===
âœ“ Framebuffer info available!
  framebuffer_addr:   0x?lx
  framebuffer_pitch:  0
  framebuffer_width:  160
  framebuffer_height: 80
  framebuffer_bpp:    25
  framebuffer_type:   0
=============================================

task init
[init_task] kstack virt=0xC02A3160
[task_load] user task: cr3=NULL (will be set by task_prepare_pde)
start user task 
Tag 0: type=21, size=12
Tag 1: type=1, size=9
Tag 2: type=2, size=29
Tag 3: type=10, size=28
Tag 4: type=3, size=17
mod 0: start=0x3CB000 end=0x3CDA80 cmdline=
Tag 5: type=6, size=160
Tag 6: type=9, size=780
Tag 7: type=4, size=16
Tag 8: type=5, size=20
Tag 9: type=8, size=32
Tag 10: type=14, size=28
[user_task_main] START: th=0xC02A2160
User task started (task=0xC02A2160)
[user_task_main] Calling task_prepare_pde for th=0xC02A2160
[task_prepare_pde] START for task=0xC02A2160
[task_prepare_pde] User task using kernel CR3: 0x101000 (shared with all)
[task_prepare_pde] task->pde=0x101000 (kernel page directory)
[task_prepare_pde] Calling load_module_to_user...
[load_module_to_user] Starting...
[load_module_to_user] Module: start=0x3CB000 end=0x3CDA80 size=0x2A80 cmdline=
[load_module_to_user] Raw physical bytes at 0x3CB000: ?2x ?2x ?2x ?2x
[load_module_to_user] ELF header at virtual 0xC03CB000
[load_module_to_user] First 4 bytes: 0x7F 0x45 0x4C 0x46
[load_module_to_user] ELF file validated!
[load_module_to_user] e_entry=0x8000143, e_phoff=52, e_phnum=3
[load_module_to_user] Program Header 0: p_type=0x1
[load_module_to_user] PT_LOAD: va=0x8000000, file_pa=0x3CC000, memsz=0x820, filesz=0x820
[load_module_to_user] Starting page mapping loop...
[load_module_to_user] Loop: off=0, dst_va=0x8000000
[load_module_to_user] Copied 0x820 bytes from ELF to new page
[load_module_to_user] Calling map_page: dst_va=0x8000000 dst_pa=0x2401000
[map_page] vaddr=0x8000000 new PT at phys=0x2402000
[map_page] Set pd_user[32]=0x2402007
[map_page] Set pt[0]=0x2401007 (vaddr=0x8000000 -> paddr=0x2401000)
[load_module_to_user] Page mapping loop done.
[load_module_to_user] Program Header 1: p_type=0x4
[load_module_to_user] Program Header 2: p_type=0x6474E551
[load_module_to_user] Set tf->eip = 0x8000143 (from ELF entry)
[load_module_to_user] Set segment registers: CS=0x1B, DS/ES/FS/GS/SS=0x23
[load_module_to_user] Set tf->eflags = 0x200
[load_module_to_user] Mapping user stack (4 pages)...
[load_module_to_user] Allocated stack page 0: phys=0x2403000
[load_module_to_user] Mapping stack page: va=0xBFFFF000 -> pa=0x2403000
[map_page] vaddr=0xBFFFF000 new PT at phys=0x2404000
[map_page] Set pd_user[767]=0x2404007
[map_page] Set pt[1023]=0x2403007 (vaddr=0xBFFFF000 -> paddr=0x2403000)
[load_module_to_user] Allocated stack page 1: phys=0x2405000
[load_module_to_user] Mapping stack page: va=0xBFFFE000 -> pa=0x2405000
[map_page] vaddr=0xBFFFE000 reusing existing pd_user[767]=0x2404007
[map_page] Set pt[1022]=0x2405007 (vaddr=0xBFFFE000 -> paddr=0x2405000)
[load_module_to_user] Allocated stack page 2: phys=0x2406000
[load_module_to_user] Mapping stack page: va=0xBFFFD000 -> pa=0x2406000
[map_page] vaddr=0xBFFFD000 reusing existing pd_user[767]=0x2404007
[map_page] Set pt[1021]=0x2406007 (vaddr=0xBFFFD000 -> paddr=0x2406000)
[load_module_to_user] Allocated stack page 3: phys=0x2407000
[load_module_to_user] Mapping stack page: va=0xBFFFC000 -> pa=0x2407000
[map_page] vaddr=0xBFFFC000 reusing existing pd_user[767]=0x2404007
[map_page] Set pt[1020]=0x2407007 (vaddr=0xBFFFC000 -> paddr=0x2407000)
[load_module_to_user] User stack mapping complete.
[load_module_to_user] Set task->user_stack = 0x2403000 (physical address of stack top)
[load_module_to_user] Set up user stack ABI (Linux standard):
  argc=0 at [ESP]=0xBFFFEFFC
  argv[0]=NULL at [ESP+4]=0xBFFFF000
  Stack protected with 32 NULL dwords (128 bytes) below stack_top
[load_module_to_user] Trapframe setup:
  eip=0x8000143, esp=0xBFFFEFFC
  cs=0x1B, ss=0x23, ds=0x23, eflags=0x200
[task_prepare_pde] load_module_to_user returned, checking EIP...
[task_prepare_pde] task->tf=0xC02A3114, task->tf->eip=0x8000143
[task_prepare_pde] Verifying trapframe:
  eip=0x8000143, cs=0x1B, eflags=0x200, esp=0xBFFFEFFC
[task_prepare_pde] User stack already mapped by load_module_to_user (4 pages = 16KB)
[task_prepare_pde] User stack VA range: 0xBFFFB000 - 0xBFFFF000
[task_prepare_pde] Keeping tf->esp=0xBFFFEFFC (set by load_module_to_user)
[task_prepare_pde] This ESP points to argc, following Linux ABI standard
[user_task_main] Initialization complete, returning to scheduler
[start_task] DEBUG: pid=1, first_task=0xC02A2160, current_task[0]=0xC02A2160
[start_task] Added task pid=1 to chain: prev->pid=1, next->pid=1
[kernel_main] User task initialized, state=PS_CREATED
user task 0xC02A2160 kernel task 0x0
Starting scheduler with multiple tasks...
[schedule] ENTRY - schedule() called!
[schedule] Initialized schedule_switch_to_return_addr=0xC011279D
[schedule] cpu_id=0
[schedule] Before inline asm
[schedule] After inline asm, flags=0x282
[pick_next_task_cfs] current: pid=1, state=64, user_stack=0x2403000
[pick_next_task_cfs] current->next=0xC02A2160
[pick_next_task_cfs] no other task, keeping current: pid=1
[schedule] first_time_user=1, switch_to_user=0 (user_stack=0x2403000, state=64)
[schedule] First time entering user mode for pid=1
[schedule] About to call task_to_user_mode_with_task, next=0xC02A2160
[task_to_user_mode_wrapper] ENTRY: task=0xC02A2160
[task_to_user_mode_wrapper] task=0xC02A2160, pid=1
[task_to_user_mode_wrapper] task->tf=0xC02A3114
[task_to_user_mode_wrapper] trapframe content:
  eip=0x8000143, cs=0x1B, eflags=0x200
  esp=0xBFFFEFFC, ss=0x23
  eax=0x0 (should be 0 for child)
[task_to_user_mode_wrapper] task_volatile = 0xC02A2160 (about to call task_to_user_mode_with_task)
[task_to_user_mode_with_task] EBX (current_task[0]) = 0xC02A2160
[syscall] SYS_PUTCHAR: char=0x53 ('S')
S[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x74 ('t')
t[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x61 ('a')
a[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x72 ('r')
r[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0x74 ('t')
t[syscall] SYS_PUTCHAR: done, eax=0
[syscall] SYS_PUTCHAR: char=0xA ('
')

[syscall] SYS_PUTCHAR: done, eax=0
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A2160, parent->tf=0xC02A3114, parent->kstack=0xC02A3160
[do_fork] Temporarily switched CR3: 0x101000 -> 0x101003
[do_fork] Mapping child task struct to kernel page table: phys=0x2408000, virt=0xC2408000
[map_page] vaddr=0xC2408000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[8]=0x2408003 (vaddr=0xC2408000 -> paddr=0x2408000)
[do_fork] Child task struct mapped
[do_fork] Child task struct virt=0xC2408000, kstack_phys=0x2409000, kstack_virt=0xC2409000, esp=0xC240A000
[do_fork] Mapping child kstack to kernel page table: phys=0x2409000, virt=0xC2409000
[map_page] vaddr=0xC2409000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[9]=0x2409003 (vaddr=0xC2409000 -> paddr=0x2409000)
[do_fork] Child kernel stack mapped to kernel page table
[do_fork] Creating independent page directory for child...
[do_fork] Allocated child PD: phys=0x240A000, virt=0xC240A000
[do_fork] Copied kernel mappings (768-1023)
[do_fork] memcpy: parent_pt_virt=0xC2402000, child_pt_virt=0xC240B000
[do_fork] Copied PD[32]: parent_pt=0x2402000 -> child_pt=0x240B000
[do_fork] memcpy: parent_pt_virt=0xC2404000, child_pt_virt=0xC240C000
[do_fork] Copied PD[767]: parent_pt=0x2404000 -> child_pt=0x240C000
[do_fork] Copied user space page tables (0-767)
[do_fork] Child using independent CR3: 0x240A000
[do_fork] DEBUG: child task struct addr=0xC2408000
[do_fork] DEBUG: &child->tf=0xC2408098, offset=152
[do_fork] DEBUG: child->tf=0xC2409FB4 (value stored)
[do_fork] Before memcpy: child->tf=0xC2409FB4, parent->tf=0xC02A3114, size=76
[do_fork] Trapframe copied successfully
[do_fork] Trapframe copied: eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Parent tf at 0xC02A3114, Child tf at 0xC2409FB4, sizeof(tf)=76
[do_fork] Child trapfield DUMP:
  eip=0x80002A3, cs=0x1B, eflags=0x282
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0, ebx=0xA, ecx=0x0, edx=0x0
  esi=0x0, edi=0x0, ebp=0xBFFFEFF8
[do_fork] Child sharing parent's address space (including user stack)
[do_fork] âš ï¸ WARNING: Multiple children will overwrite each other's user stack!
[do_fork] âš ï¸ TODO: Implement COW (Copy-On-Write) mechanism
[do_fork] Child trapframe ready: tf=0xC2409FB4, eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Child will enter user mode via task_to_user_mode_with_task
[do_fork] Found first_task: pid=1
[do_fork] Added child to circular list: prev->pid=1, next->pid=1
[do_fork] Child PID=2 created successfully, state=64 (PS_CREATED)
[do_fork] Restored CR3: 0x101003 -> 0x101000
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A2160, parent->tf=0xC02A3114, parent->kstack=0xC02A3160
[do_fork] Temporarily switched CR3: 0x101000 -> 0x101003
[do_fork] Mapping child task struct to kernel page table: phys=0x240D000, virt=0xC240D000
[map_page] vaddr=0xC240D000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[13]=0x240D003 (vaddr=0xC240D000 -> paddr=0x240D000)
[do_fork] Child task struct mapped
[do_fork] Child task struct virt=0xC240D000, kstack_phys=0x240E000, kstack_virt=0xC240E000, esp=0xC240F000
[do_fork] Mapping child kstack to kernel page table: phys=0x240E000, virt=0xC240E000
[map_page] vaddr=0xC240E000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[14]=0x240E003 (vaddr=0xC240E000 -> paddr=0x240E000)
[do_fork] Child kernel stack mapped to kernel page table
[do_fork] Creating independent page directory for child...
[do_fork] Allocated child PD: phys=0x240F000, virt=0xC240F000
[do_fork] Copied kernel mappings (768-1023)
[do_fork] memcpy: parent_pt_virt=0xC2402000, child_pt_virt=0xC2410000
[do_fork] Copied PD[32]: parent_pt=0x2402000 -> child_pt=0x2410000
[do_fork] memcpy: parent_pt_virt=0xC2404000, child_pt_virt=0xC2411000
[do_fork] Copied PD[767]: parent_pt=0x2404000 -> child_pt=0x2411000
[do_fork] Copied user space page tables (0-767)
[do_fork] Child using independent CR3: 0x240F000
[do_fork] DEBUG: child task struct addr=0xC240D000
[do_fork] DEBUG: &child->tf=0xC240D098, offset=152
[do_fork] DEBUG: child->tf=0xC240EFB4 (value stored)
[do_fork] Before memcpy: child->tf=0xC240EFB4, parent->tf=0xC02A3114, size=76
[do_fork] Trapframe copied successfully
[do_fork] Trapframe copied: eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Parent tf at 0xC02A3114, Child tf at 0xC240EFB4, sizeof(tf)=76
[do_fork] Child trapfield DUMP:
  eip=0x80002A3, cs=0x1B, eflags=0x202
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0, ebx=0xA, ecx=0x0, edx=0x0
  esi=0x0, edi=0x0, ebp=0xBFFFEFF8
[do_fork] Child sharing parent's address space (including user stack)
[do_fork] âš ï¸ WARNING: Multiple children will overwrite each other's user stack!
[do_fork] âš ï¸ TODO: Implement COW (Copy-On-Write) mechanism
[do_fork] Child trapframe ready: tf=0xC240EFB4, eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Child will enter user mode via task_to_user_mode_with_task
[do_fork] Found first_task: pid=1
[do_fork] Added child to circular list: prev->pid=2, next->pid=1
[do_fork] Child PID=3 created successfully, state=64 (PS_CREATED)
[do_fork] Restored CR3: 0x101003 -> 0x101000
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A2160, parent->tf=0xC02A3114, parent->kstack=0xC02A3160
[do_fork] Temporarily switched CR3: 0x101000 -> 0x101003
[do_fork] Mapping child task struct to kernel page table: phys=0x2412000, virt=0xC2412000
[map_page] vaddr=0xC2412000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[18]=0x2412003 (vaddr=0xC2412000 -> paddr=0x2412000)
[do_fork] Child task struct mapped
[do_fork] Child task struct virt=0xC2412000, kstack_phys=0x2413000, kstack_virt=0xC2413000, esp=0xC2414000
[do_fork] Mapping child kstack to kernel page table: phys=0x2413000, virt=0xC2413000
[map_page] vaddr=0xC2413000 reusing existing pd_user[777]=0x205023
[map_page] Set pt[19]=0x2413003 (vaddr=0xC2413000 -> paddr=0x2413000)
[do_fork] Child kernel stack mapped to kernel page table
[do_fork] Creating independent page directory for child...
[do_fork] Allocated child PD: phys=0x2414000, virt=0xC2414000
[do_fork] Copied kernel mappings (768-1023)
[do_fork] memcpy: parent_pt_virt=0xC2402000, child_pt_virt=0xC2415000
[do_fork] Copied PD[32]: parent_pt=0x2402000 -> child_pt=0x2415000
[do_fork] memcpy: parent_pt_virt=0xC2404000, child_pt_virt=0xC2416000
[do_fork] Copied PD[767]: parent_pt=0x2404000 -> child_pt=0x2416000
[do_fork] Copied user space page tables (0-767)
[do_fork] Child using independent CR3: 0x2414000
[do_fork] DEBUG: child task struct addr=0xC2412000
[do_fork] DEBUG: &child->tf=0xC2412098, offset=152
[do_fork] DEBUG: child->tf=0xC2413FB4 (value stored)
[do_fork] Before memcpy: child->tf=0xC2413FB4, parent->tf=0xC02A3114, size=76
[do_fork] Trapframe copied successfully
[do_fork] Trapframe copied: eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Parent tf at 0xC02A3114, Child tf at 0xC2413FB4, sizeof(tf)=76
[do_fork] Child trapfield DUMP:
  eip=0x80002A3, cs=0x1B, eflags=0x206
  esp=0xBFFFEFDC, ss=0x23
  eax=0x0, ebx=0xA, ecx=0x0, edx=0x0
  esi=0x0, edi=0x0, ebp=0xBFFFEFF8
[do_fork] Child sharing parent's address space (including user stack)
[do_fork] âš ï¸ WARNING: Multiple children will overwrite each other's user stack!
[do_fork] âš ï¸ TODO: Implement COW (Copy-On-Write) mechanism
[do_fork] Child trapframe ready: tf=0xC2413FB4, eip=0x80002A3, esp=0xBFFFEFDC
[do_fork] Child will enter user mode via task_to_user_mode_with_task
[do_fork] Found first_task: pid=1
[do_fork] Added child to circular list: prev->pid=3, next->pid=1
[do_fork] Child PID=4 created successfully, state=64 (PS_CREATED)
[do_fork] Restored CR3: 0x101003 -> 0x101000
[do_fork] Parent PID=1 forking...
[do_fork] parent=0xC02A2160, parent->tf=0xC02A3114, parent->kstack=0xC02A3160
[do_fork] Tempora