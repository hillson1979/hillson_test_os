# 内核调试成功总结

**日期**: 2025-12-28
**测试内存**: 4GB
**测试环境**: QEMU i386

---

## 一、问题背景

内核在启动用户进程时遇到 **Page Fault (中断 14)**，错误地址为 `0x2401C00`，栈指针 `esp=0x4`（严重异常）。

---

## 二、调试过程

### 1. 初步诊断
- 错误类型：Page Fault（中断 14）
- 故障地址：CR2 = 0x2401C00
- 栈指针：esp = 0x4 / 0x1（异常值）
- 位置：`copy_kernel_mappings_to_pd()` 函数

### 2. 根本原因分析

#### 问题 1: trapframe 位置计算错误
**文件**: [task.c:346](task.c#L346)

**原代码**:
```c
newtask->tf = (struct trapframe *)((uint8_t*)newtask->kstack + 4096 - sizeof(struct trapframe));
```

**问题**:
- `newtask->kstack` 指向页尾：`(uint8_t*)page + PAGE_SIZE`
- 加上 4096 后超出页边界，导致栈损坏
- esp 被设置为异常值（0x1, 0x4 等）

**修复**:
```c
newtask->tf = (struct trapframe *)((uint8_t*)newtask->kstack - sizeof(struct trapframe));
```

#### 问题 2: copy_kernel_mappings_to_pd() 参数类型错误
**文件**: [task.c:186](task.c#L186)

**原代码**:
```c
copy_kernel_mappings_to_pd(th_u->pde);  // 传入物理地址 0x2401000
```

**问题**:
- `th_u->pde` 是物理地址（0x2401000）
- `copy_kernel_mappings_to_pd()` 需要虚拟地址来访问数组
- 访问物理地址触发 Page Fault

**修复**:
```c
copy_kernel_mappings_to_pd(pd_user);  // 传入虚拟地址 0xC2401000
```

---

## 三、修复验证

### 测试输出
```
[task_prepare_pde] START
[alloc_page_table_] Before memset: pg.virt=0xC2401000, phys=0x2401000
[alloc_page_table_] After memset succeeded
[task_prepare_pde] th_u->pde=0x2401000, pd_user=0xC2401000
[copy_kernel_mappings_to_pd] START: pd_user=0xC2401000
[copy_kernel_mappings_to_pd] Loop i=768
[copy_kernel_mappings_to_pd] pd[768]=0x102023
[copy_kernel_mappings_to_pd] Writing to pd_user[768]=0x102023
[copy_kernel_mappings_to_pd] Wrote pd_user[768]=0x102023
...
[copy_kernel_mappings_to_pd] END
```

### 结果
✅ **无 Page Fault**
✅ **copy_kernel_mappings_to_pd() 成功执行**
✅ **所有 256 个内核 PDE 条目成功复制**

---

## 四、当前状态

### 已完成
1. ✅ Buddy System 初始化（管理 36MB-3071MB 物理内存）
2. ✅ 用户页目录分配（通过 pmm_alloc_page）
3. ✅ 按需映射实现（在 `alloc_page_table_()` 中）
4. ✅ 内核映射复制（768-1023 PDE 索引）
5. ✅ Page Fault 完全修复

### 待完成
❌ **用户模块加载**: `mods_count=0`

**原因**: QEMU 的 `-kernel` 参数不支持 multiboot 模块加载

**解决方案**:
1. 使用 GRUB 引导的 ISO 镜像
2. 需要安装 genisoimage 创建 ISO
3. 当前正在 WSL 中安装 genisoimage

---

## 五、技术要点

### 内存布局
- **物理内存**: 0x0 - 0xBFF7FFFF (3071 MB)
- **Buddy System**: 0x2400000 - 0xBFF7FFFF (36MB - 3071MB)
- **内核映射**: 0xC0000000 - 0xC07FFFFF (恒等映射 0-8MB)
- **高内存映射**: 0xC0800000+ (按需映射)
- **Buddy 元数据**: 0xC1000000 - 0xC2FFFFFF (16MB-48MB 预映射)

### 按需映射机制
```c
// 在 alloc_page_table_() 中实现
uint32_t virt_addr = (uint32_t)phys_to_virt(phys);  // 0xC0000000 + phys
uint32_t kernel_pd_index = virt_addr >> 22;          // PD 索引

if (!(pd[kernel_pd_index] & PAGE_PRESENT)) {
    map_4k_page(phys, virt_addr, 0x3);  // 创建页表和映射
} else {
    uint32_t *kernel_pt = (uint32_t*)phys_to_virt(pd[kernel_pd_index] & ~0xFFF);
    kernel_pt[kernel_pt_index] = phys | 0x3;  // 仅创建页映射
    invlpg(virt_addr);  // 刷新 TLB
}
```

### Trapframe 布局
```c
task_t 结构:     0x0000 - 0x0FFF (页首)
kernel stack:    0x1000 - 0x1F00 (从低地址向高地址增长)
trapframe:       0x1F00 - 0x1FFC (栈顶下方)
stack top:       0x2000 (页尾)
```

---

## 六、测试命令

### 单独测试内核
```bash
qemu-system-i386 -kernel kernel.bin -m 4096 -nographic
```

### 测试 ISO（需要 genisoimage）
```bash
# 创建 ISO
bash create_iso.sh

# 运行 ISO
qemu-system-i386 -cdrom os.iso -m 4096 -nographic
```

### GDB 调试
```bash
# QEMU 端
qemu-system-i386 -kernel kernel.bin -m 4096 -s -S

# GDB 端
gdb kernel.bin
(gdb) target remote 192.168.157.134:1234
(gdb) break task_prepare_pde
(gdb) continue
```

---

## 七、下一步计划

1. **完成 genisoimage 安装**（进行中）
2. **创建 os.iso 镜像**
3. **测试用户 shell 程序**
4. **验证系统调用功能**

---

## 八、文件变更记录

### 修改的文件
1. **task.c** (lines 299, 186)
   - 修复 trapframe 位置计算
   - 修复 copy_kernel_mappings_to_pd() 参数

2. **userboot.c** (lines 32-53)
   - 添加 mods_count 检查
   - 添加详细的调试输出

3. **create_iso.sh** (新建)
   - ISO 镜像创建脚本

---

## 九、参考资料

- Intel® 64 and IA-32 Architectures Software Developer's Manual
- Multiboot Specification
- GRUB Documentation

---

**调试完成时间**: 2025-12-28
**内核版本**: hillson_test_os v0.1
**调试工具**: GDB, QEMU
